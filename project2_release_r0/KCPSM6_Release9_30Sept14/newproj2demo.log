KCPSM6 Assembler log file for program 'C:\540_proj2\project2_release_r0\KCPSM6_Release9_30Sept14\newproj2demo.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 28 Oct 2014
Assembly timestamp: 10:21:46

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3FF hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 332
Memory locations available: 3764


Assembly listing

 Addr Code                   Instruction

 000                         ; -----------------------------------------------------------------
 000                         ; proj2demo.psm - Demo program for Rojobot "world" emulator
 000                         ;
 000                         ; Version: 4.0
 000                         ; Author: Roy Kravitz
 000                         ; Date:  12-Oct-2014
 000                         ;
 000                         ; Revision History
 000                         ; ================
 000                         ; 11-Jan-07  RK  Created the first version
 000                         ; 12-Jan-09  RK  Modified for S3E Starter Board and Seven Segment Emulator
 000                         ; 16-Oct-09  RK  Minor changes (comments) for PSU ECE510
 000                         ; 24-Oct-11  RK  Minor changes (comments)
 000                         ; 24-Oct-12  RK  Modified for kcpsm6 and Nexys 3
 000                         ; 03-Jan-14  RK  Refactored as Project1 demo for ECE 540 Winter 2014 and later
 000                         ; 26-Jan-14  RK  Fixed bug in Interrupt handler.  S5 and S6 were inadvertently swapped
 000                         ;      Thanks to Jason Dutra for pointing this out.
 000                         ; 11-Oct-14  RK  Refactored as Project 2 demo for ECE 540 Fall 2014 and later.  Includes
 000                         ;      support for Nexys4 and Vivado, including a workaround for a bug in the
 000                         ;      Vivdao hardware manager (2014.2) pointed out by Ken Chapman.  The bug
 000                         ;      corrupts location 3 of the ROM so the code is written to avoid that location
 000                         ; 12-Oct-14  RK  Modified code to take advantage of the 8 digit Nexys4 (vs. 4 on the Nexys3) display
 000                         ;
 000                         ; Description:
 000                         ; ============
 000                         ; This program demonstrate the Rojobot world emulator.  It is modelled after
 000                         ; the the Verilog Rojobot implemented in the Getting Started application only this demo is based
 000                         ; on the full Rojobot emulator (as implemented in bot.v instead of the simplified
 000                         ; Rojobot model used in the Getting Started project
 000                         ;
 000                         ; The demo uses the 4 pushbuttons to control the Rojobot as follows:
 000                         ; btn_left - Left Motor forward
 000                         ;  btn_up  - Left Motor reverse
 000                         ; btn_right - Right Motor forward
 000                         ; btn_down - Right Motor reverse
 000                         ; If neither of the two buttons that control each motor is pushed, then the motor is stopped.
 000                         ; If both of the two buttons that control each motor are pushed, the actions cancel each other
 000                         ; leaving the motor stopped.
 000                         ;
 000                         ; The demo takes advantage of the wider display on the Nexys4 (8 digits vs. 4) to
 000                         ; make the rojobot state easier for follow. The digits are mapped as follows:
 000                         ; digit[7:5] - compass heading
 000                         ; digit[4] - movement (Fwd, Rev, Stopped, turning)
 000                         ; digits[2:1] - column position (X) in hex
 000                         ; digits[1:0] - row position (Y) in hex
 000                         ;
 000                         ; Decimal points 5 and 4 are turned on to highlight the movement display.  Decimal point 0 toggles
 000                         ; on and off every interrupt (~every 100 msec w/ updt_sysregs)
 000                         ; The sensors are displayed on the LEDs in both display modes.
 000                         ; Decimal point 0 toggles on and off every interrupt (~every 100 msec w/ updt_sysregs)
 000                         ;
 000                         ; NOTE:  NOT ALL THE CODE IN THIS EXAMPLE IS USED.  THE EXAMPLE WAS CREATED TO GIVE YOU, THE
 000                         ; STUDENT, AN EXAMPLE OF HOW TO CONTROL THE ROJOBOT AND NEXYS4 PERIPHERALS FROM AN EMBEDDED PICOBLAZE
 000                         ; CPU. YOU MAY (OR NOT) FIND SOME OF THIS CODE APPLICABLE TO YOUR OTHER PROJECTS
 000                         ;
 000                         ; -----------------------------------------------------------------
 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s6 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, LocX                 ; rojobot location - x coordinate
 000                         NAMEREG sE, LocY                 ; rojobot location - y coordinate
 000                         NAMEREG sD, Sensor               ; rojobot sensor values
 000                         NAMEREG sC, Botinf               ; rojobot movement and orientation values
 000                         NAMEREG sB, MVst                 ; state variable for movement indicator
 000                         ;
 000                         ; Dig7, Dig6, Dig5 and Dig4 are stored in the scratchpad
 000                         ; RAM to keep the changes to minimum
 000                         NAMEREG sA, Dig3                 ; 7-segment display digit 3
 000                         NAMEREG s9, Dig2                 ; 7-segment display digit 2
 000                         NAMEREG s8, Dig1                 ; 7-segment display digit 1
 000                         NAMEREG s7, Dig0                 ; 7-segment display digit 0
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ; Nexys 4 board base I/O interface ports compatible with the Nexys3 I/O interface
 000                         ;  Port Addresses
 000                         CONSTANT PA_PBTNS, 00            ; (i) pushbuttons inputs
 000                         CONSTANT PA_SLSWTCH, 01          ; (i) slide switches
 000                         CONSTANT PA_LEDS, 02             ; (o) LEDs
 000                         CONSTANT PA_DIG3, 03             ; (o) digit 3 port address
 000                         CONSTANT PA_DIG2, 04             ; (o) digit 2 port address
 000                         CONSTANT PA_DIG1, 05             ; (o) digit 1 port address
 000                         CONSTANT PA_DIG0, 06             ; (o) digit 0 port address
 000                         CONSTANT PA_DP, 07               ; (o) decimal points 3:0 port address
 000                         CONSTANT PA_RSVD, 08             ; (o) *RESERVED* port address
 000                         ; Rojobot interface registers
 000                         CONSTANT PA_MOTCTL_IN, 09        ; (o) Rojobot motor control output from system
 000                         CONSTANT PA_LOCX, 0A             ; (i) X coordinate of rojobot location
 000                         CONSTANT PA_LOCY, 0B             ; (i))Y coordinate of rojobot location
 000                         CONSTANT PA_BOTINFO, 0C          ; (i) Rojobot info register
 000                         CONSTANT PA_SENSORS, 0D          ; (i) Sensor register
 000                         CONSTANT PA_LMDIST, 0E           ; (i) Rojobot left motor distance register
 000                         CONSTANT PA_RMDIST, 0F           ; (i) Rojobot right motor distance register
 000                         ; Extended I/O interface port addresses for the Nexys4.  Your Nexys4_Bot interface module
 000                         ; should include these additional ports even though they are not used in this program
 000                         CONSTANT PA_PBTNS_ALT, 10        ; (i) pushbutton inputs alternate port address
 000                         CONSTANT PA_SLSWTCH1508, 11      ; (i) slide switches 15:8 (high byte of switches
 000                         CONSTANT PA_LEDS1508, 12         ; (o) LEDs 15:8 (high byte of switches)
 000                         CONSTANT PA_DIG7, 13             ; (o) digit 7 port address
 000                         CONSTANT PA_DIG6, 14             ; (o) digit 6 port address
 000                         CONSTANT PA_DIG5, 15             ; (o) digit 5 port address
 000                         CONSTANT PA_DIG4, 16             ; (o) digit 4 port address
 000                         CONSTANT PA_DP0704, 17           ; (o) decimal points 7:4 port address
 000                         CONSTANT PA_RSVD_ALT, 18         ; (o) *RESERVED* alternate port address
 000                         ; Extended Rojobot interface registers.  These are alternate Port addresses
 000                         CONSTANT PA_MOTCTL_IN_ALT, 19    ; (o) Rojobot motor control output from system
 000                         CONSTANT PA_LOCX_ALT, 1A         ; (i) X coordinate of rojobot location
 000                         CONSTANT PA_LOCY_ALT, 1B         ; (i))Y coordinate of rojobot location
 000                         CONSTANT PA_BOTINFO_ALT, 1C      ; (i) Rojobot info register
 000                         CONSTANT PA_SENSORS_ALT, 1D      ; (i) Sensor register
 000                         CONSTANT PA_LMDIST_ALT, 1E       ; (i) Rojobot left motor distance register
 000                         CONSTANT PA_RMDIST_ALT, 1F       ; (i) Rojobot right motor distance register
 000                         ; =====================================
 000                         ; === Register bit mappings (masks) ===
 000                         ; =====================================
 000                         ;  bit masks for pushbuttons and switches for seven segment emulator
 000                         CONSTANT MSK_ALLBTNS, 1F         ; Buttons are in bits[5:0]
 000                         CONSTANT MSK_PBTNS, 0F           ; Mask for 4 buttons to display on LED
 000                         CONSTANT MSK_BTN_CENTER, 10      ; Pushbutton Center is bit 4
 000                         CONSTANT MSK_BTN_LEFT, 08        ; Pushbutton Left is bit 3
 000                         CONSTANT MSK_BTN_UP, 04          ; Pushbutton Up is bit 2
 000                         CONSTANT MSK_BTN_RIGHT, 02       ; Pushbutton Right is bit 1
 000                         CONSTANT MSK_BTN_DOWN, 01        ; Pushbutton Down is bit 0
 000                         CONSTANT MSK_ALLSW_LO, FF        ; Slide switches are in bits[7:0] of PA_SLSWTCH_07_00
 000                         CONSTANT MSK_ALLSW_HI, FF        ; Slide switchees are in bits[7:0] of PA_SLSWTCH_15_08
 000                         CONSTANT MSK_SW7, 80             ; Slide switch 7 is bit 7
 000                         CONSTANT MSK_SW6, 40             ; Slide switch 6 is bit 6
 000                         CONSTANT MSK_SW5, 20             ; Slide switch 5 is bit 5
 000                         CONSTANT MSK_SW4, 10             ; Slide switch 4 is bit 4
 000                         CONSTANT MSK_SW3, 08             ; Slide switch 3 is bit 3
 000                         CONSTANT MSK_SW2, 04             ; Slide switch 2 is bit 2
 000                         CONSTANT MSK_SW1, 02             ; Slide switch 1 is bit 1
 000                         CONSTANT MSK_SW0, 01             ; Slide switch 0 is bit 0
 000                         CONSTANT MSK_SW15, 80            ; Slide switch 15 is bit 7
 000                         CONSTANT MSK_SW14, 40            ; Slide switch 14 is bit 6
 000                         CONSTANT MSK_SW13, 20            ; Slide switch 13 is bit 5
 000                         CONSTANT MSK_SW12, 10            ; Slide switch 12 is bit 4
 000                         CONSTANT MSK_SW11, 08            ; Slide switch 11 is bit 3
 000                         CONSTANT MSK_SW10, 04            ; Slide switch 10 is bit 2
 000                         CONSTANT MSK_SW09, 02            ; Slide switch 09 is bit 1
 000                         CONSTANT MSK_SW08, 01            ; Slide switch 08 is bit 0
 000                         ; bit mask for LEDs
 000                         CONSTANT MSK_LEDS_LO, FF         ; Mask for rightmost 8 LEDs on the Nexys4
 000                         CONSTANT MSK_LEDS_HI, FF         ; Mask for the lefmost 8 LEDs on the Nexys4
 000                         ; bit mask for display character codes and decimal points
 000                         CONSTANT MSK_CCODE, 1F           ; Character codes are in lower 5 bits
 000                         CONSTANT MSK_DECPTS, 0F          ; Decimal points 3 - 0 are in bits 3 to 0
 000                         CONSTANT MSK_DECPTS_HI, 0F       ; Decimal points 7-4 are in bits 3 to 0
 000                         CONSTANT MSK_HEXDIGIT, 0F        ; Hex digits only take 4 bits
 000                         ; nibble masks
 000                         CONSTANT MSKLOWNIB, 0F           ; Mask out high nibble of byte
 000                         CONSTANT MSKHIGHNIB, F0          ; Mask out low nibble of byte
 000                         CONSTANT INVLOWNIB, 0F           ; Invert low nibble of byte
 000                         ; =============================
 000                         ; === Useful Data Constants ===
 000                         ; =============================
 000                         ;  Constants for True and False and Null
 000                         CONSTANT FALSE, 00
 000                         CONSTANT TRUE, 01
 000                         CONSTANT NULL, 00
 000                         ; Character code table for special characters
 000                         ; Decimal digits 0 to 15 display '0'to 'F'
 000                         CONSTANT CC_BASE, 10             ; Base value for special characters
 000                         CONSTANT CC_SEGBASE, 10          ; Base value for segment display special characters
 000                         ;     abcdefg
 000                         CONSTANT CC_SEGA, 10             ; Segment A  [1000000]
 000                         CONSTANT CC_SEGB, 11             ; Segment B  [0100000]
 000                         CONSTANT CC_SEGC, 12             ; Segment C  [0010000]
 000                         CONSTANT CC_SEGD, 13             ; Segment D  [0001000]
 000                         CONSTANT CC_SEGE, 14             ; Segment E  [0000100]
 000                         CONSTANT CC_SEGF, 15             ; Segment F  [0000010]
 000                         CONSTANT CC_SEGG, 16             ; Segment G  [0000001]
 000                         CONSTANT CC_DOT, 17              ; Dot (period)
 000                         CONSTANT CC_UCH, 18              ; Upper Case H
 000                         CONSTANT CC_UCL, 19              ; Upper Case L
 000                         CONSTANT CC_UCR, 1A              ; Upper Case R
 000                         CONSTANT CC_LCL, 1B              ; Lower Case L
 000                         CONSTANT CC_LCR, 1C              ; Lower Case R
 000                         CONSTANT CC_SPACE1, 1D           ; Space (blank)
 000                         CONSTANT CC_SPACE2, 1E           ; Space (blank)
 000                         CONSTANT CC_SPACE, 1F            ; Space (blank)
 000                         ; ======================
 000                         ; === BotInfo values ===
 000                         ; ======================
 000                         CONSTANT OR_N, 00                ; Orientation is North
 000                         CONSTANT OR_NE, 01               ; Orientation is Northeast
 000                         CONSTANT OR_E, 02                ; Orientation is East
 000                         CONSTANT OR_SE, 03               ; Orientation is Southeast
 000                         CONSTANT OR_S, 04                ; Orientation is South
 000                         CONSTANT OR_SW, 05               ; Orientation is Southwest
 000                         CONSTANT OR_W, 06                ; Orientation is West
 000                         CONSTANT OR_NW, 07               ; Orientation is Northwest
 000                         CONSTANT MV_STOP, 00             ; Movement is stopped
 000                         CONSTANT MV_FWD, 04              ; Movement is forward
 000                         CONSTANT MV_REV, 08              ; Movement is reverse
 000                         CONSTANT MV_SLT, 0C              ; Movement is slow left turn
 000                         CONSTANT MV_FLT, 0D              ; Movement is fast left turn
 000                         CONSTANT MV_SRT, 0E              ; Movement is slow right turn
 000                         CONSTANT MV_FRT, 0F              ; Movement is fast right turn
 000                         ; Next 2 contants assume field is in low nibble
 000                         CONSTANT MSKMVMT, 0F             ; Mask out all but movement bits
 000                         CONSTANT MSKORIENT, 07           ; Mask out all but orientation bits
 000                         ; =================================
 000                         ; === Scratch Pad RAM Variables ===
 000                         ; =================================
 000                         ; Pushbutton translation lookup table.  Converts pushbutton combos
 000                         ; to Motor Control input register format [lmspd[2:0],lmdir,rmspd[2:0],rmdir]
 000                         CONSTANT SP_BTNBASE, 00          ; table is based at 0x00
 000                         ;        [b3,b2,b1,b0]=[lf,lr,rf,rr]
 000                         CONSTANT SP_LSRS, 00             ; left motor off, right motor off     [0000]
 000                         CONSTANT SP_LORR, 02             ; left motor off, right motor reverse   [0001]
 000                         CONSTANT SP_LSRF, 03             ; left motor off, right motor forward   [0010]
 000                         CONSTANT SP_LSRFR, 00            ; left motor off, right motor fwd & rev = off [0011]
 000                         CONSTANT SP_LRRS, 20             ; left motor reverse, right motor off   [0100]
 000                         CONSTANT SP_LRRR, 22             ; left motor reverse, right motor reverse  [0101]
 000                         CONSTANT SP_LRRF, 23             ; left motor reverse, right motor forward  [0110]
 000                         CONSTANT SP_LRRFR, 20            ; left motor rev, right motor fwd & rev = off [0111]
 000                         CONSTANT SP_LFRS, 30             ; left motor forward, right motor off    [1000]
 000                         CONSTANT SP_LFRR, 32             ; left motor forward, right motor reverse  [1001]
 000                         CONSTANT SP_LFRF, 33             ; left motor forward, right motor forward  [1010]
 000                         CONSTANT SP_LFRFR, 30            ; left motor fwd, right motor fwd & rev = off [1011]
 000                         CONSTANT SP_LFRRS, 00            ; left motor fwd & rev = off, right motor off [1100]
 000                         CONSTANT SP_LFRRR, 02            ; left motor fwd & rev = off, right motor rev [1101]
 000                         CONSTANT SP_LFRRF, 03            ; left motor fwd & rev = off, right motor fwd [1110]
 000                         CONSTANT SP_LFRRFR, 00           ; left  and right motor fwd & rev = off   [1111]
 000                         ; Movement display lookup table.  Converts movement from BotInfo register to
 000                         ; the character code to display.  Not very dense but we have the room in the SP RAM and
 000                         ; it saves building a switch statement into the code.
 000                         CONSTANT SP_MVMTBASE, 10         ; table is based at 0x10
 000                         CONSTANT SP_MVMT0, 18            ; Stopped - display upper case H
 000                         CONSTANT SP_MVMT1, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT2, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT3, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT4, 0F            ; Forward - display upper case F
 000                         CONSTANT SP_MVMT5, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT6, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT7, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT8, 0B            ; Reverse (Backward) - display lower case B
 000                         CONSTANT SP_MVMT9, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTA, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTB, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTC, 19            ; Slow left turn - display upper case L
 000                         CONSTANT SP_MVMTD, 1B            ; Fast left turn - display lower case L
 000                         CONSTANT SP_MVMTE, 1A            ; Slow right turn - display upper case R
 000                         CONSTANT SP_MVMTF, 1C            ; Fast right turn - display lower case R
 000                         ; ==============================
 000                         ; === Storage for old values ===
 000                         ; ==============================
 000                         CONSTANT SP_SEM, 20              ; Semaphore between isr and main loop
 000                         CONSTANT SP_TEMP1, 21            ; Temp storage.  Used by ISR
 000                         CONSTANT SP_TEMP2, 22            ;
 000                         CONSTANT SP_LMDIST, 23           ; Storage for left and right motor distance counters
 000                         CONSTANT SP_RMDIST, 24           ;
 000                         CONSTANT SP_OLDMVMT, 25          ; Old movement value
 000                         CONSTANT SP_OLDHDG, 26           ; Old heading value
 000                         CONSTANT SP_OLDDP, 27            ; Old decimal points
 000                         ; =========================
 000                         ; === Digits 7, 6, 5, 4 ===
 000                         ;==========================
 000                         CONSTANT SP_DIG7, 30             ; Digit[7:4] contain the BOT heading
 000                         CONSTANT SP_DIG6, 31             ;
 000                         CONSTANT SP_DIG5, 32             ;
 000                         CONSTANT SP_DIG4, 33             ;
 000                         ; ===============
 000                         ; === main()  ===
 000                         ; ===============
 000                         ADDRESS 000
 000  22004                  JUMP 004[main]                   ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                   ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                   ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                   ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004  20035            main: CALL 035[init_btnluptbl]         ; initialize button to MotCtl lookup table
 005  2006C                  CALL 06C[init_mvmttbl]           ; initialize movement to character code lookup table
 006  01100                  LOAD s1, 00                      ; clear the semaphore
 007  2F120                  STORE s1, 20[SP_SEM]             ;
 008  01100                  LOAD s1, 00                      ; turn off decimal points 3-0.  Decimal point 0 (rightmost
 009  2F127                  STORE s1, 27[SP_OLDDP]           ; and save the value
 00A  2012D                  CALL 12D[SS_wrdpts]              ; will be toggled in the interrupt handler
 00B  01103                  LOAD s1, 03                      ; turn on decimal points 5 and 4 to offset the movement digit
 00C  20131                  CALL 131[SS_wrdpts_hi]           ; we don't need to save this value because these decimal points don't change
 00D  28001                  ENABLE INTERRUPT                 ; get the ball rolling
 00E                         ; ==================
 00E                         ; === Main  Loop ===
 00E                         ; ==================
 00E                         ; while(1) {  // main loop is an infinite loop
 00E  0B620         main_L0: FETCH s6, 20[SP_SEM]             ;  while (SP_SEMA == 0)  {}   // loop until isr updates rojobot registers
 00F  1D600                  COMPARE s6, 00                   ;
 010  3200E                  JUMP Z, 00E[main_L0]             ;
 011  200DE                  CALL 0DE[next_loc]               ;   Dig[3:2] = nex LocX; Dig[1:0] = next LocY
 012  200A3                  CALL 0A3[next_mvmt]              ;   Dig[4] = next movement
 013  200AB                  CALL 0AB[next_hdg]               ;   Dig[7:4] = next heading
 014                         ;  }
 014  2001C         main_L2: CALL 01C[wr_alldigits]           ;  write all of the digits to the display
 015  001D0                  LOAD s1, sD[Sensor]              ;  update LEDs with new sensor information
 016  2010F                  CALL 10F[LED_wrleds]             ;
 017  200EF                  CALL 0EF[next_step]              ;  tell rojobot what to do next
 018  0B620                  FETCH s6, 20[SP_SEM]
 019  19601                  SUB s6, 01                       ;  decrement semaphore
 01A  2F620                  STORE s6, 20[SP_SEM]             ;
 01B  2200E                  JUMP 00E[main_L0]                ; } // end - main while loop
 01C                         ;**************************************************************************************
 01C                         ; Support functions
 01C                         ;**************************************************************************************
 01C                         ; ===============================================================================
 01C                         ; === wr_alldigits() - Writes all 8 display digits from the global locations  ===
 01C                         ; === Registers used s0,s1,s2, Dig0, Dig1, Dig2, Dig3                         ===
 01C                         ; --- Scratchpad RAM locations used SP_DIG4, SP_DIG5, SP_DIG6, SP_DIG7        ===
 01C                         ; ===============================================================================
 01C           wr_alldigits: ; Digits 0 to 3 are stored in registers
 01C                         ; and written to the didsplay with SS_wdigx()
 01C  01200                  LOAD s2, 00                      ; point at digit 0
 01D  00170                  LOAD s1, s7[Dig0]                ; and write it to display
 01E  20117                  CALL 117[SS_wrdigx]              ;
 01F  01201                  LOAD s2, 01                      ; point at digit 1
 020  00180                  LOAD s1, s8[Dig1]                ; and write it to display
 021  20117                  CALL 117[SS_wrdigx]              ;
 022  01202                  LOAD s2, 02                      ; point at digit 2
 023  00190                  LOAD s1, s9[Dig2]                ; and write it to display
 024  20117                  CALL 117[SS_wrdigx]              ;
 025  01203                  LOAD s2, 03                      ; point at digit 3
 026  001A0                  LOAD s1, sA[Dig3]                ; and write it to the display
 027  20117                  CALL 117[SS_wrdigx]              ;
 028                         ; Digits 4 to 7 are stored in the Scratchpad RAM
 028                         ; and written to the display with SS_wdigx_hi()
 028  01204                  LOAD s2, 04                      ; point at digit 4
 029  0B133                  FETCH s1, 33[SP_DIG4]            ; and write it to the display
 02A  20120                  CALL 120[SS_wrdigx_hi]           ;
 02B  01205                  LOAD s2, 05                      ; point at digit 5
 02C  0B132                  FETCH s1, 32[SP_DIG5]            ; and write it to the display
 02D  20120                  CALL 120[SS_wrdigx_hi]           ;
 02E  01206                  LOAD s2, 06                      ; point at digit 6
 02F  0B131                  FETCH s1, 31[SP_DIG6]            ; and write it to the display
 030  20120                  CALL 120[SS_wrdigx_hi]           ;
 031  01207                  LOAD s2, 07                      ; point at digit 7
 032  0B130                  FETCH s1, 30[SP_DIG7]            ; and write it to the display
 033  20120                  CALL 120[SS_wrdigx_hi]           ;
 034  25000                  RETURN 
 035                         ;*******
 035                         ; Functions to convert pushbutton presses to Motor Control input
 035                         ;*******
 035                         ; ===============================================================================
 035                         ; === init_btnluptbl() - initialize button translation lookup table in SP RAM ===
 035                         ; === Registers affected: s0, s1                                              ===
 035                         ; ===============================================================================
 035  01000  init_btnluptbl: LOAD s0, 00[SP_BTNBASE]          ; s0 gets base of button translation lookup table
 036  01100                  LOAD s1, 00[SP_LSRS]             ; s1 gets values for 0x00
 037  2E100                  STORE s1, (s0)                   ; store the entry in the table
 038  11001                  ADD s0, 01                       ; increment the table index
 039  01102                  LOAD s1, 02[SP_LORR]             ; s1 gets values for 0x01
 03A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03B  11001                  ADD s0, 01                       ; increment the table index
 03C  01103                  LOAD s1, 03[SP_LSRF]             ; s1 gets values for 0x02
 03D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03E  11001                  ADD s0, 01                       ; increment the table index
 03F  01100                  LOAD s1, 00[SP_LSRFR]            ; s1 gets values for 0x03
 040  2E100                  STORE s1, (s0)                   ; store the entry in the table
 041  11001                  ADD s0, 01                       ; increment the table index
 042  01120                  LOAD s1, 20[SP_LRRS]             ; s1 gets values for 0x04
 043  2E100                  STORE s1, (s0)                   ; store the entry in the table
 044  11001                  ADD s0, 01                       ; increment the table index
 045  01122                  LOAD s1, 22[SP_LRRR]             ; s1 gets values for 0x05
 046  2E100                  STORE s1, (s0)                   ; store the entry in the table
 047  11001                  ADD s0, 01                       ; increment the table index
 048  01123                  LOAD s1, 23[SP_LRRF]             ; s1 gets values for 0x06
 049  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04A  11001                  ADD s0, 01                       ; increment the table index
 04B  01120                  LOAD s1, 20[SP_LRRFR]            ; s1 gets values for 0x07
 04C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04D  11001                  ADD s0, 01                       ; increment the table index
 04E  01130                  LOAD s1, 30[SP_LFRS]             ; s1 gets values for 0x08
 04F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 050  11001                  ADD s0, 01                       ; increment the table index
 051  01132                  LOAD s1, 32[SP_LFRR]             ; s1 gets values for 0x09
 052  2E100                  STORE s1, (s0)                   ; store the entry in the table
 053  11001                  ADD s0, 01                       ; increment the table index
 054  01133                  LOAD s1, 33[SP_LFRF]             ; s1 gets values for 0x0A
 055  2E100                  STORE s1, (s0)                   ; store the entry in the table
 056  11001                  ADD s0, 01                       ; increment the table index
 057  01130                  LOAD s1, 30[SP_LFRFR]            ; s1 gets values for 0x0B
 058  2E100                  STORE s1, (s0)                   ; store the entry in the table
 059  11001                  ADD s0, 01                       ; increment the table index
 05A  01100                  LOAD s1, 00[SP_LFRRS]            ; s1 gets values for 0x0C
 05B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 05C  11001                  ADD s0, 01                       ; increment the table index
 05D  01102                  LOAD s1, 02[SP_LFRRR]            ; s1 gets values for 0x0D
 05E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 05F  11001                  ADD s0, 01                       ; increment the table index
 060  01103                  LOAD s1, 03[SP_LFRRF]            ; s1 gets values for 0x0E
 061  2E100                  STORE s1, (s0)                   ; store the entry in the table
 062  11001                  ADD s0, 01                       ; increment the table index
 063  01100                  LOAD s1, 00[SP_LFRRFR]           ; s1 gets values for 0x0F
 064  2E100                  STORE s1, (s0)                   ; store the entry in the table
 065  25000                  RETURN                           ; done...at last
 066                         ; =============================================================================
 066                         ; === btn2mot() - Button to MotCtl conversion function                      ===
 066                         ; === Registers affected: s1, s2                                            ===
 066                         ; === s0 contains the button value to convert.                              ===
 066                         ; === Result (Motor Control register value) is returned in s1               ===
 066                         ; === s0 (Button value) is not changed                                      ===
 066                         ; =============================================================================
 066  01200         btn2mot: LOAD s2, 00[SP_BTNBASE]          ; s2 gets base of button conversion table
 067  00100                  LOAD s1, s0                      ; mask out upper nibble of buttons
 068  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 069  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 06A  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 06B  25000                  RETURN 
 06C                         ; ===============================================================================
 06C                         ; === init_mvmttbl() - initialize movement translation lookup table in SP RAM ===
 06C                         ; === Registers affected: s0, s1                                              ===
 06C                         ; ===============================================================================
 06C  01010    init_mvmttbl: LOAD s0, 10[SP_MVMTBASE]         ; s0 gets base of movement translation lookup table
 06D  01118                  LOAD s1, 18[SP_MVMT0]            ; s1 gets values for 0x00
 06E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 06F  11001                  ADD s0, 01                       ; increment the table index
 070  01117                  LOAD s1, 17[SP_MVMT1]            ; s1 gets values for 0x01
 071  2E100                  STORE s1, (s0)                   ; store the entry in the table
 072  11001                  ADD s0, 01                       ; increment the table index
 073  01117                  LOAD s1, 17[SP_MVMT2]            ; s1 gets values for 0x02
 074  2E100                  STORE s1, (s0)                   ; store the entry in the table
 075  11001                  ADD s0, 01                       ; increment the table index
 076  01117                  LOAD s1, 17[SP_MVMT3]            ; s1 gets values for 0x03
 077  2E100                  STORE s1, (s0)                   ; store the entry in the table
 078  11001                  ADD s0, 01                       ; increment the table index
 079  0110F                  LOAD s1, 0F[SP_MVMT4]            ; s1 gets values for 0x04
 07A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07B  11001                  ADD s0, 01                       ; increment the table index
 07C  01117                  LOAD s1, 17[SP_MVMT5]            ; s1 gets values for 0x05
 07D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07E  11001                  ADD s0, 01                       ; increment the table index
 07F  01117                  LOAD s1, 17[SP_MVMT6]            ; s1 gets values for 0x06
 080  2E100                  STORE s1, (s0)                   ; store the entry in the table
 081  11001                  ADD s0, 01                       ; increment the table index
 082  01117                  LOAD s1, 17[SP_MVMT7]            ; s1 gets values for 0x07
 083  2E100                  STORE s1, (s0)                   ; store the entry in the table
 084  11001                  ADD s0, 01                       ; increment the table index
 085  0110B                  LOAD s1, 0B[SP_MVMT8]            ; s1 gets values for 0x08
 086  2E100                  STORE s1, (s0)                   ; store the entry in the table
 087  11001                  ADD s0, 01                       ; increment the table index
 088  01117                  LOAD s1, 17[SP_MVMT9]            ; s1 gets values for 0x09
 089  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08A  11001                  ADD s0, 01                       ; increment the table index
 08B  01117                  LOAD s1, 17[SP_MVMTA]            ; s1 gets values for 0x0A
 08C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08D  11001                  ADD s0, 01                       ; increment the table index
 08E  01117                  LOAD s1, 17[SP_MVMTB]            ; s1 gets values for 0x0B
 08F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 090  11001                  ADD s0, 01                       ; increment the table index
 091  01119                  LOAD s1, 19[SP_MVMTC]            ; s1 gets values for 0x0C
 092  2E100                  STORE s1, (s0)                   ; store the entry in the table
 093  11001                  ADD s0, 01                       ; increment the table index
 094  0111B                  LOAD s1, 1B[SP_MVMTD]            ; s1 gets values for 0x0D
 095  2E100                  STORE s1, (s0)                   ; store the entry in the table
 096  11001                  ADD s0, 01                       ; increment the table index
 097  0111A                  LOAD s1, 1A[SP_MVMTE]            ; s1 gets values for 0x0E
 098  2E100                  STORE s1, (s0)                   ; store the entry in the table
 099  11001                  ADD s0, 01                       ; increment the table index
 09A  0111C                  LOAD s1, 1C[SP_MVMTF]            ; s1 gets values for 0x0F
 09B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 09C  25000                  RETURN                           ; done...at last
 09D                         ; =============================================================================
 09D                         ; === mvmt2cc() - movement to character code conversion function            ===
 09D                         ; === Registers affected: s1, s2                                            ===
 09D                         ; === s0 contains the movment value to convert.                             ===
 09D                         ; === Result (character code to display) is returned in s1                  ===
 09D                         ; === s0 (movement) is not changed                                          ===
 09D                         ; =============================================================================
 09D  01210         mvmt2cc: LOAD s2, 10[SP_MVMTBASE]         ; s2 gets base of movment conversion table
 09E  00100                  LOAD s1, s0                      ; mask out upper nibble of movment
 09F  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 0A0  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 0A1  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 0A2  25000                  RETURN 
 0A3                         ;#########################################
 0A3                         ; Modify this function for Project 2 #####
 0A3                         ;#########################################
 0A3                         ; ========================================================================
 0A3                         ; === next_mvmt() - Calculate  digit for motion indicator              ===
 0A3                         ; === Registers affected: Dig3, s0                                     ===
 0A3                         ; === Uses Botinf (Bot Info register) to get movement.                 ===
 0A3                         ; ========================================================================
 0A3  000C0       next_mvmt: LOAD s0, sC[Botinf]              ; s0[3:0] = Botinf[7:4]
 0A4  1400E                  SR0 s0                           ;
 0A5  1400E                  SR0 s0                           ;
 0A6  1400E                  SR0 s0                           ;
 0A7  1400E                  SR0 s0                           ;
 0A8  2009D                  CALL 09D[mvmt2cc]                ; translate movement to char code
 0A9  2F133                  STORE s1, 33[SP_DIG4]            ; and move to digit 4.
 0AA  25000                  RETURN                           ; digit 4 is in the scratchpad RAM
 0AB                         ; ==============================================================================
 0AB                         ; === next_hdg() - Calculate  digits for heading (compass setting)           ===
 0AB                         ; === Registers affected: Dig2, Dig1, Dig0, s0, s1, s2, s3,s4, s5, s6        ===
 0AB                         ; === Uses Botinf (Bot Info register) to get orientation.  Calculates digits ===
 0AB                         ; === with a case statement based on orientation.                            ===
 0AB                         ; ==============================================================================
 0AB  000C0        next_hdg: LOAD s0, sC[Botinf]              ; s0[2:0] = Botinf[2:0] = orientation
 0AC  03007                  AND s0, 07[MSKORIENT]            ;
 0AD                         ; switch(orientation)  {
 0AD  1D000      nh_caseORN: COMPARE s0, 00[OR_N]             ; case(OR_N):
 0AE  360B3                  JUMP NZ, 0B3[nh_caseORNE]        ;
 0AF  01400                  LOAD s4, 00                      ;  Dig[2:0] = 000
 0B0  01500                  LOAD s5, 00                      ;
 0B1  01600                  LOAD s6, 00                      ;
 0B2  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0B3                         ;
 0B3  1D001     nh_caseORNE: COMPARE s0, 01[OR_NE]            ; case (OR_NE):
 0B4  360B9                  JUMP NZ, 0B9[nh_caseORE]         ;
 0B5  01400                  LOAD s4, 00                      ;  Dig[2:0] = 045
 0B6  01504                  LOAD s5, 04                      ;
 0B7  01605                  LOAD s6, 05                      ;
 0B8  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0B9  1D002      nh_caseORE: COMPARE s0, 02[OR_E]             ; case (OR_E):
 0BA  360BF                  JUMP NZ, 0BF[nh_caseORSE]        ;
 0BB  01400                  LOAD s4, 00                      ;  Dig[2:0] = 090
 0BC  01509                  LOAD s5, 09                      ;
 0BD  01600                  LOAD s6, 00                      ;
 0BE  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0BF  1D003     nh_caseORSE: COMPARE s0, 03[OR_SE]            ; case (OR_SE):
 0C0  360C5                  JUMP NZ, 0C5[nh_caseORS]         ;
 0C1  01401                  LOAD s4, 01                      ;  Dig[2:0] = 135
 0C2  01503                  LOAD s5, 03                      ;
 0C3  01605                  LOAD s6, 05                      ;
 0C4  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0C5  1D004      nh_caseORS: COMPARE s0, 04[OR_S]             ; case (OR_S):
 0C6  360CB                  JUMP NZ, 0CB[nh_caseORSW]        ;
 0C7  01401                  LOAD s4, 01                      ;  Dig[2:0] = 180
 0C8  01508                  LOAD s5, 08                      ;
 0C9  01600                  LOAD s6, 00                      ;
 0CA  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0CB  1D005     nh_caseORSW: COMPARE s0, 05[OR_SW]            ; case (OR_SW):
 0CC  360D1                  JUMP NZ, 0D1[nh_caseORW]         ;
 0CD  01402                  LOAD s4, 02                      ;  Dig[2:0] = 225
 0CE  01502                  LOAD s5, 02                      ;
 0CF  01605                  LOAD s6, 05                      ;
 0D0  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0D1  1D006      nh_caseORW: COMPARE s0, 06[OR_W]             ; case (OR_W):
 0D2  360D7                  JUMP NZ, 0D7[nh_caseORNW]        ;
 0D3  01402                  LOAD s4, 02                      ;  Dig[2:0] = 270
 0D4  01507                  LOAD s5, 07                      ;
 0D5  01600                  LOAD s6, 00                      ;
 0D6  220DA                  JUMP 0DA[nh_endcase]             ;  break;
 0D7                         ; case (OR_NW):  // only remaining case
 0D7  01403     nh_caseORNW: LOAD s4, 03                      ;  Dig[2:0] = 315
 0D8  01501                  LOAD s5, 01                      ;
 0D9  01605                  LOAD s6, 05                      ;
 0DA                         ; } // end of switch statement
 0DA  2F430      nh_endcase: STORE s4, 30[SP_DIG7]            ; update the heading display digits
 0DB  2F531                  STORE s5, 31[SP_DIG6]            ; these are stored in the Scratchpad RAM
 0DC  2F632                  STORE s6, 32[SP_DIG5]            ;
 0DD  25000                  RETURN 
 0DE                         ; ==============================================================================
 0DE                         ; === next_loc() - Calculate digits for Rojobot location                     ===
 0DE                         ; === Registers affected: Dig3, Dig2, Dig1, Dig0, s0                         ===
 0DE                         ; === Uses LocX and LocY to get location.                                    ===
 0DE                         ; ==============================================================================
 0DE  000F0        next_loc: LOAD s0, sF[LocX]                ; Dig[3:2] gets X-coordinate
 0DF  00900                  LOAD s9[Dig2], s0                ; Digit 2 gets lower nibble
 0E0  0390F                  AND s9[Dig2], 0F[MSK_HEXDIGIT]   ;
 0E1  1400E                  SR0 s0                           ; Digit3 gets upper nibble
 0E2  1400E                  SR0 s0                           ;
 0E3  1400E                  SR0 s0                           ;
 0E4  1400E                  SR0 s0                           ;
 0E5  00A00                  LOAD sA[Dig3], s0                ;
 0E6  000E0                  LOAD s0, sE[LocY]                ; Dig[1:0] gets Y-coordinate
 0E7  00700                  LOAD s7[Dig0], s0                ; Digit 0 gets lower nibble
 0E8  0370F                  AND s7[Dig0], 0F[MSK_HEXDIGIT]   ;
 0E9  1400E                  SR0 s0                           ; Digit 1 gets upper nibble
 0EA  1400E                  SR0 s0                           ;
 0EB  1400E                  SR0 s0                           ;
 0EC  1400E                  SR0 s0                           ;
 0ED  00800                  LOAD s8[Dig1], s0                ;
 0EE  25000                  RETURN 
 0EF                         ;#########################################
 0EF                         ; Modify this function for Project 2 #####
 0EF                         ;#########################################
 0EF                         ; ==============================================================================
 0EF                         ; === next_step() - Tells rojobot what to do next                            ===
 0EF                         ; === Registers affected: s0, s1                                             ===
 0EF                         ; === This version reads the pushbuttons, calculates the new Motor Control   ===
 0EF                         ; === register value and then writes MotCtl so Rojobot knows what to do      ===
 0EF                         ; ==============================================================================
 0EF  20106       next_step: CALL 106[DEB_rdbtns]             ; Read the pushbuttons. buttons returned in s0
 0F0  200F6                  CALL 0F6[find_line]              ; See if the line is under the bot. returns movement needed in s0
 0F1                         ;CALL  btn2mot      ; and calculate new MotCtl - returned in s1
 0F1                         ;OUTPUT s1,  PA_MOTCTL_IN  ; tell Rojobot what to do
 0F1  25000                  RETURN 
 0F2  01000            stop: LOAD s0, 00[SP_LSRS]             ; load stop from table into s0 (pass to btn2mot function)
 0F3  20066                  CALL 066[btn2mot]                ; and calculate new MotCtl - returned in s1
 0F4  2D109                  OUTPUT s1, 09[PA_MOTCTL_IN]      ; tell Rojobot what to do
 0F5  25000                  RETURN 
 0F6  001D0       find_line: LOAD s1, sD[Sensor]              ;read the sensor into s1
 0F7  003C0                  LOAD s3, sC[Botinf]              ;read the botinfo into s3
 0F8  1400E                  SR0 s0                           ;
 0F9  1400E                  SR0 s0                           ;
 0FA  1400E                  SR0 s0                           ;
 0FB  1400E                  SR0 s0                           ;
 0FC  00410                  LOAD s4, s1                      ; load sensor info into s4
 0FD  03407                  AND s4, 07                       ;mask out unused bits (00000111 = 7 hex)
 0FE  1D400                  COMPARE s4, 00                   ;check to see if the line is there
 0FF  360F2                  JUMP NZ, 0F2[stop]               ;if line is not there stop
 100  01033                  LOAD s0, 33[SP_LFRF]             ;load forward from table into s0 (pass to btn2mot function)
 101  20066                  CALL 066[btn2mot]                ;and calculate new MotCtl - returned in s1
 102  2D109                  OUTPUT s1, 09[PA_MOTCTL_IN]      ;tell Rojobot what to do
 103  1D300                  COMPARE s3, 00                   ;check to see if the bot is going forward
 104  320F6                  JUMP Z, 0F6[find_line]           ;if stopped continue find_line loop until bot moves
 105  25000                  RETURN                           ;if bot moved go back to main
 106                         ;*************************
 106                         ; Nexys4 I/O Functions
 106                         ;*************************
 106                         ;---------------------
 106                         ; DEB_rdbtns() - Reads the debounced pushbuttons
 106                         ;
 106                         ; Returns the 5 pushbuttons. The buttons are returned as follows
 106                         ; (assuming the inputs to the I/O interface matches this order)
 106                         ; example:
 106                         ;    bit  7    6      5        4        3        2        1         0
 106                         ;         r    r      r    btn_cntr  btn_left  btn_up  btn_right  btn_down
 106                         ;
 106                         ; where r = reserved. A value of 1 indicates that the button is pressed.
 106                         ; A 0 indicates that the button is not pressed.
 106                         ;
 106                         ; Registers used s0
 106                         ;---------------------
 106  09000      DEB_rdbtns: INPUT s0, 00[PA_PBTNS]           ; read the buttons
 107  0301F                  AND s0, 1F[MSK_ALLBTNS]          ; mask out unused bits
 108  25000                  RETURN                           ; and return
 109                         ;---------------------
 109                         ; DEB_rdsw() - Reads the low order debounced switches
 109                         ;
 109                         ; Returns the  low order switches  [7:0]. The switches are returned as follows
 109                         ; example:
 109                         ;    bit  7    6    5   4    3    2    1    0
 109                         ;        sw7  sw6  sw5 sw4  sw3  sw2  sw1  sw0
 109                         ;
 109                         ; where r = reserved, sw7 is the leftmost switch and sw0 is the rightmost
 109                         ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 109                         ; the switch is off (down).
 109                         ;
 109                         ; Registers used s0
 109                         ;---------------------
 109  09001        DEB_rdsw: INPUT s0, 01[PA_SLSWTCH]         ; read the slide switches
 10A  030FF                  AND s0, FF[MSK_ALLSW_LO]         ; mask out unused bits
 10B  25000                  RETURN                           ; and return
 10C                         ;---------------------
 10C                         ; DEB_rdsw_hi() - Reads the high order debounced switches
 10C                         ;
 10C                         ; Returns the  high order switches  [155432:0]. The switches are returned as follows
 10C                         ; example:
 10C                         ;    bit   7     6     5    4     3     2     1    0
 10C                         ;        sw15  sw14  sw13 sw12  sw11  sw10  sw9  sw8
 10C                         ;
 10C                         ; where r = reserved, sw15 is the leftmost switch and sw7 is the rightmost
 10C                         ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 10C                         ; the switch is off (down).
 10C                         ;
 10C                         ; Registers used s0
 10C                         ;---------------------
 10C  09011     DEB_rdsw_hi: INPUT s0, 11[PA_SLSWTCH1508]     ; read the slide switches
 10D  030FF                  AND s0, FF[MSK_ALLSW_HI]         ; mask out unused bits
 10E  25000                  RETURN                           ; and return
 10F                         ;---------------------
 10F                         ; LED_wrleds() - Write the low order 8 LEDs
 10F                         ;
 10F                         ; Writes the pattern in s1 to the rightmost 8 LEDs on the Nexys4
 10F                         ;
 10F                         ; Registers used s0, s1
 10F                         ;---------------------
 10F  00010      LED_wrleds: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 110  030FF                  AND s0, FF[MSK_LEDS_LO]          ; mask out unused bits
 111  2D002                  OUTPUT s0, 02[PA_LEDS]           ; and write pattern to the LEDs
 112  25000                  RETURN                           ; and return
 113                         ;---------------------
 113                         ; LED_wrleds_hi() - Write the high order 8 LEDs
 113                         ;
 113                         ; Writes the pattern in s1 to the lefmost 8 LEDs on the Nexys4
 113                         ;
 113                         ; Registers used s0, s1
 113                         ;---------------------
 113  00010   LED_wrleds_hi: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 114  030FF                  AND s0, FF[MSK_LEDS_HI]          ; mask out unused bits
 115  2D012                  OUTPUT s0, 12[PA_LEDS1508]       ; and write pattern to the LEDs
 116  25000                  RETURN                           ; and return
 117                         ;---------------------
 117                         ; SS_wrdigx() - Write a digit to the righmost 4 display digits
 117                         ;
 117                         ; Writes the value specified in s1 to the digit number
 117                         ; in s2.  The digit number must be 0, 1, 2, or 3
 117                         ; All others numbers will be rejected.
 117                         ;
 117                         ; Registers used s0, s1, s2, s3
 117                         ;---------------------
 117  01003       SS_wrdigx: LOAD s0, 03                      ; check to see if the number is <= 3
 118  1C020                  COMPARE s0, s2                   ;
 119  39000                  RETURN C                         ; C=1 says s2 > 3 - out of range so return
 11A  01006    SS_wrdigx_L1: LOAD s0, 06[PA_DIG0]             ; set base port address to PA_DIG0
 11B  18020                  SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 11C                         ; for the selected digit.  Cool - it works because the port
 11C                         ; addresses for the digits are consecutive starting with digit 3 or 7
 11C  00310                  LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 11D  0331F                  AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 11E  2C300                  OUTPUT s3, (s0)                  ; abd write the digit to the display at the port pointed to by s0
 11F  25000                  RETURN 
 120                         ;---------------------
 120                         ; SS_wrdigx_hi() - Write a digit to the leftmost 4 display digits
 120                         ;
 120                         ; Writes the value specified in s1 to the digit number
 120                         ; in s2.  The digit number must be 4, 5, 6, 7
 120                         ; All others numbers will be rejected.
 120                         ;
 120                         ; Registers used s0, s1, s2, s3
 120                         ;---------------------
 120  01007    SS_wrdigx_hi: LOAD s0, 07                      ; check if the number is <= 7
 121  1C020                  COMPARE s0, s2                   ;
 122  39000                  RETURN C                         ; C=10 says s2 <= 07 - out of range so return
 123  01003                  LOAD s0, 03                      ; next check if the number is >= 3
 124  1C020                  COMPARE s0, s2                   ; next check if the number is > 3
 125  3D000                  RETURN NC                        ; C=0 says s2 < 4 - out of range so return
 126  01016                  LOAD s0, 16[PA_DIG4]             ; set base port address to PA_DIG4
 127  11004                  ADD s0, 04                       ; adjust digit number offset (ex: digit 4 should be PA_DIG4+4-4)
 128  18020                  SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 129                         ; for the selected digit.  Cool - it works because the port
 129                         ; addresses for the digits are consecutive starting with digit 3 or 7
 129  00310                  LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 12A  0331F                  AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 12B  2C300                  OUTPUT s3, (s0)                  ; and write the digit to the display at the port pointed to by s0
 12C  25000                  RETURN 
 12D                         ;---------------------
 12D                         ; SS_wrdpts() - Write the decimal points for digit 3 to 0 to the display
 12D                         ;
 12D                         ; Writes the decimal points specified in s1 to the display.
 12D                         ; The decimal point register is formatted as follows:
 12D                         ;    bit   7  6  5  4   3    2     1     0
 12D                         ;          r  r  r  r  dp3  dp2   dp1   dp0
 12D                         ;
 12D                         ; where r = reserved, dp7 (leftmost), dp3, dp2, dp1 dp0 (rightmost) = 1
 12D                         ; lights the decimal point. A 0 in the position turns off the decimal point
 12D                         ;
 12D                         ; Registers used s0,s1
 12D                         ;---------------------
 12D  00010       SS_wrdpts: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 12E  0300F                  AND s0, 0F[MSK_DECPTS]           ; and mask out the unused bits
 12F  2D007                  OUTPUT s0, 07[PA_DP]             ; write the decimal points to the display
 130  25000                  RETURN 
 131                         ;---------------------
 131                         ; SS_wrdpts_hi() - Write the decimal points for digit 7 to 4 to the display
 131                         ;
 131                         ; Writes the decimal points specified in s1 to the display.
 131                         ; The decimal point register is formatted as follows:
 131                         ;    bit   7  6  5  4   3    2     1     0
 131                         ;          r  r  r  r  dp7  dp6   dp5   dp4
 131                         ;
 131                         ; where r = reserved, dp7 (leftmost), dp7, dp6, dp5 dp4 (rightmost) = 1
 131                         ; lights the decimal point. A 0 in the position turns off the decimal point
 131                         ;
 131                         ; Registers used s0,s1
 131                         ;---------------------
 131  00010    SS_wrdpts_hi: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 132  0300F                  AND s0, 0F[MSK_DECPTS_HI]        ; and mask out the unused bits
 133  2D017                  OUTPUT s0, 17[PA_DP0704]         ; write the decimal points to the display
 134  25000                  RETURN 
 135                         ; =========================
 135                         ; === Interrupt Handler ===
 135                         ; =========================
 300                         ADDRESS 300
 300  2F621             isr: STORE s6, 21[SP_TEMP1]           ;  save s6, s5
 301  2F522                  STORE s5, 22[SP_TEMP2]           ;
 302  0B620                  FETCH s6, 20[SP_SEM]             ;  fetch the semaphore
 303  0D6FF                  TEST s6, FF                      ; if (SP_SEM == 0) {  // update system register values
 304  3630F                  JUMP NZ, 30F[isr_L0]             ; -- ZF == 0 says semaphore != 0
 305                         ;  // no - get the data from the rojobot emulator
 305  09F0A                  INPUT sF[LocX], 0A[PA_LOCX]      ;  get Rojobot X-coordinate
 306  09E0B                  INPUT sE[LocY], 0B[PA_LOCY]      ;  get Rojobot Y-coordinate
 307  09C0C                  INPUT sC[Botinf], 0C[PA_BOTINFO] ;  get Rojobot Movement and Orientation
 308  09D0D                  INPUT sD[Sensor], 0D[PA_SENSORS] ;  get Rojobot Sensors
 309  0950E                  INPUT s5, 0E[PA_LMDIST]          ;  get left and right motor distance counters
 30A  2F523                  STORE s5, 23[SP_LMDIST]          ;  not displayed in this program but let's stash them
 30B  0950F                  INPUT s5, 0F[PA_RMDIST]          ;  in case we decide we need them
 30C  2F524                  STORE s5, 24[SP_RMDIST]          ;
 30D  11601                  ADD s6, 01                       ;  increment semaphore
 30E  2F620                  STORE s6, 20[SP_SEM]             ; }  // update system register values
 30F  0B627          isr_L0: FETCH s6, 27[SP_OLDDP]           ; toggle  decimal point 0 (rightmost)
 310  07601                  XOR s6, 01                       ;
 311  2D607                  OUTPUT s6, 07[PA_DP]             ; write directly to decpt port to avoid having to save s1
 312  2F627                  STORE s6, 27[SP_OLDDP]           ;
 313  0B621                  FETCH s6, 21[SP_TEMP1]           ;  restore s6, s5
 314  0B522                  FETCH s5, 22[SP_TEMP2]           ;
 315  29001                  RETURNI ENABLE                   ; and return from interrupt
 316                         ; ========================
 316                         ; === Interrupt vector ===
 316                         ; ========================
 3FF                         ADDRESS 3FF
 3FF  22300         intvect: JUMP 300[isr]                    ; jump to interrupt service routine


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\540_proj2\project2_release_r0\KCPSM6_Release9_30Sept14\newproj2demo.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   10'd         
 timestamp_minutes 21'd         
 timestamp_seconds 46'd         
 datestamp_year    14'd         
 datestamp_month   10'd         
 datestamp_day     28'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PA_PBTNS          00           newproj2demo.psm
 PA_SLSWTCH        01           newproj2demo.psm
 PA_LEDS           02           newproj2demo.psm
 PA_DIG3           03           newproj2demo.psm
 PA_DIG2           04           newproj2demo.psm
 PA_DIG1           05           newproj2demo.psm
 PA_DIG0           06           newproj2demo.psm
 PA_DP             07           newproj2demo.psm
 PA_RSVD           08           newproj2demo.psm
 PA_MOTCTL_IN      09           newproj2demo.psm
 PA_LOCX           0A           newproj2demo.psm
 PA_LOCY           0B           newproj2demo.psm
 PA_BOTINFO        0C           newproj2demo.psm
 PA_SENSORS        0D           newproj2demo.psm
 PA_LMDIST         0E           newproj2demo.psm
 PA_RMDIST         0F           newproj2demo.psm
 PA_PBTNS_ALT      10           newproj2demo.psm
 PA_SLSWTCH1508    11           newproj2demo.psm
 PA_LEDS1508       12           newproj2demo.psm
 PA_DIG7           13           newproj2demo.psm
 PA_DIG6           14           newproj2demo.psm
 PA_DIG5           15           newproj2demo.psm
 PA_DIG4           16           newproj2demo.psm
 PA_DP0704         17           newproj2demo.psm
 PA_RSVD_ALT       18           newproj2demo.psm
 PA_MOTCTL_IN_ALT  19           newproj2demo.psm
 PA_LOCX_ALT       1A           newproj2demo.psm
 PA_LOCY_ALT       1B           newproj2demo.psm
 PA_BOTINFO_ALT    1C           newproj2demo.psm
 PA_SENSORS_ALT    1D           newproj2demo.psm
 PA_LMDIST_ALT     1E           newproj2demo.psm
 PA_RMDIST_ALT     1F           newproj2demo.psm
 MSK_ALLBTNS       1F           newproj2demo.psm
 MSK_PBTNS         0F           newproj2demo.psm
 MSK_BTN_CENTER    10           newproj2demo.psm
 MSK_BTN_LEFT      08           newproj2demo.psm
 MSK_BTN_UP        04           newproj2demo.psm
 MSK_BTN_RIGHT     02           newproj2demo.psm
 MSK_BTN_DOWN      01           newproj2demo.psm
 MSK_ALLSW_LO      FF           newproj2demo.psm
 MSK_ALLSW_HI      FF           newproj2demo.psm
 MSK_SW7           80           newproj2demo.psm
 MSK_SW6           40           newproj2demo.psm
 MSK_SW5           20           newproj2demo.psm
 MSK_SW4           10           newproj2demo.psm
 MSK_SW3           08           newproj2demo.psm
 MSK_SW2           04           newproj2demo.psm
 MSK_SW1           02           newproj2demo.psm
 MSK_SW0           01           newproj2demo.psm
 MSK_SW15          80           newproj2demo.psm
 MSK_SW14          40           newproj2demo.psm
 MSK_SW13          20           newproj2demo.psm
 MSK_SW12          10           newproj2demo.psm
 MSK_SW11          08           newproj2demo.psm
 MSK_SW10          04           newproj2demo.psm
 MSK_SW09          02           newproj2demo.psm
 MSK_SW08          01           newproj2demo.psm
 MSK_LEDS_LO       FF           newproj2demo.psm
 MSK_LEDS_HI       FF           newproj2demo.psm
 MSK_CCODE         1F           newproj2demo.psm
 MSK_DECPTS        0F           newproj2demo.psm
 MSK_DECPTS_HI     0F           newproj2demo.psm
 MSK_HEXDIGIT      0F           newproj2demo.psm
 MSKLOWNIB         0F           newproj2demo.psm
 MSKHIGHNIB        F0           newproj2demo.psm
 INVLOWNIB         0F           newproj2demo.psm
 FALSE             00           newproj2demo.psm
 TRUE              01           newproj2demo.psm
 NULL              00           newproj2demo.psm
 CC_BASE           10           newproj2demo.psm
 CC_SEGBASE        10           newproj2demo.psm
 CC_SEGA           10           newproj2demo.psm
 CC_SEGB           11           newproj2demo.psm
 CC_SEGC           12           newproj2demo.psm
 CC_SEGD           13           newproj2demo.psm
 CC_SEGE           14           newproj2demo.psm
 CC_SEGF           15           newproj2demo.psm
 CC_SEGG           16           newproj2demo.psm
 CC_DOT            17           newproj2demo.psm
 CC_UCH            18           newproj2demo.psm
 CC_UCL            19           newproj2demo.psm
 CC_UCR            1A           newproj2demo.psm
 CC_LCL            1B           newproj2demo.psm
 CC_LCR            1C           newproj2demo.psm
 CC_SPACE1         1D           newproj2demo.psm
 CC_SPACE2         1E           newproj2demo.psm
 CC_SPACE          1F           newproj2demo.psm
 OR_N              00           newproj2demo.psm
 OR_NE             01           newproj2demo.psm
 OR_E              02           newproj2demo.psm
 OR_SE             03           newproj2demo.psm
 OR_S              04           newproj2demo.psm
 OR_SW             05           newproj2demo.psm
 OR_W              06           newproj2demo.psm
 OR_NW             07           newproj2demo.psm
 MV_STOP           00           newproj2demo.psm
 MV_FWD            04           newproj2demo.psm
 MV_REV            08           newproj2demo.psm
 MV_SLT            0C           newproj2demo.psm
 MV_FLT            0D           newproj2demo.psm
 MV_SRT            0E           newproj2demo.psm
 MV_FRT            0F           newproj2demo.psm
 MSKMVMT           0F           newproj2demo.psm
 MSKORIENT         07           newproj2demo.psm
 SP_BTNBASE        00           newproj2demo.psm
 SP_LSRS           00           newproj2demo.psm
 SP_LORR           02           newproj2demo.psm
 SP_LSRF           03           newproj2demo.psm
 SP_LSRFR          00           newproj2demo.psm
 SP_LRRS           20           newproj2demo.psm
 SP_LRRR           22           newproj2demo.psm
 SP_LRRF           23           newproj2demo.psm
 SP_LRRFR          20           newproj2demo.psm
 SP_LFRS           30           newproj2demo.psm
 SP_LFRR           32           newproj2demo.psm
 SP_LFRF           33           newproj2demo.psm
 SP_LFRFR          30           newproj2demo.psm
 SP_LFRRS          00           newproj2demo.psm
 SP_LFRRR          02           newproj2demo.psm
 SP_LFRRF          03           newproj2demo.psm
 SP_LFRRFR         00           newproj2demo.psm
 SP_MVMTBASE       10           newproj2demo.psm
 SP_MVMT0          18           newproj2demo.psm
 SP_MVMT1          17           newproj2demo.psm
 SP_MVMT2          17           newproj2demo.psm
 SP_MVMT3          17           newproj2demo.psm
 SP_MVMT4          0F           newproj2demo.psm
 SP_MVMT5          17           newproj2demo.psm
 SP_MVMT6          17           newproj2demo.psm
 SP_MVMT7          17           newproj2demo.psm
 SP_MVMT8          0B           newproj2demo.psm
 SP_MVMT9          17           newproj2demo.psm
 SP_MVMTA          17           newproj2demo.psm
 SP_MVMTB          17           newproj2demo.psm
 SP_MVMTC          19           newproj2demo.psm
 SP_MVMTD          1B           newproj2demo.psm
 SP_MVMTE          1A           newproj2demo.psm
 SP_MVMTF          1C           newproj2demo.psm
 SP_SEM            20           newproj2demo.psm
 SP_TEMP1          21           newproj2demo.psm
 SP_TEMP2          22           newproj2demo.psm
 SP_LMDIST         23           newproj2demo.psm
 SP_RMDIST         24           newproj2demo.psm
 SP_OLDMVMT        25           newproj2demo.psm
 SP_OLDHDG         26           newproj2demo.psm
 SP_OLDDP          27           newproj2demo.psm
 SP_DIG7           30           newproj2demo.psm
 SP_DIG6           31           newproj2demo.psm
 SP_DIG5           32           newproj2demo.psm
 SP_DIG4           33           newproj2demo.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "28 Oct 2014"  
 timestamp$        "10:21:46"     



List of line labels

   Label            Addr  Source PSM File

   main             004   newproj2demo.psm
   main_L0          00E   newproj2demo.psm
 * main_L2          014   newproj2demo.psm
   wr_alldigits     01C   newproj2demo.psm
   init_btnluptbl   035   newproj2demo.psm
   btn2mot          066   newproj2demo.psm
   init_mvmttbl     06C   newproj2demo.psm
   mvmt2cc          09D   newproj2demo.psm
   next_mvmt        0A3   newproj2demo.psm
   next_hdg         0AB   newproj2demo.psm
 * nh_caseORN       0AD   newproj2demo.psm
   nh_caseORNE      0B3   newproj2demo.psm
   nh_caseORE       0B9   newproj2demo.psm
   nh_caseORSE      0BF   newproj2demo.psm
   nh_caseORS       0C5   newproj2demo.psm
   nh_caseORSW      0CB   newproj2demo.psm
   nh_caseORW       0D1   newproj2demo.psm
   nh_caseORNW      0D7   newproj2demo.psm
   nh_endcase       0DA   newproj2demo.psm
   next_loc         0DE   newproj2demo.psm
   next_step        0EF   newproj2demo.psm
   stop             0F2   newproj2demo.psm
   find_line        0F6   newproj2demo.psm
   DEB_rdbtns       106   newproj2demo.psm
 * DEB_rdsw         109   newproj2demo.psm
 * DEB_rdsw_hi      10C   newproj2demo.psm
   LED_wrleds       10F   newproj2demo.psm
 * LED_wrleds_hi    113   newproj2demo.psm
   SS_wrdigx        117   newproj2demo.psm
 * SS_wrdigx_L1     11A   newproj2demo.psm
   SS_wrdigx_hi     120   newproj2demo.psm
   SS_wrdpts        12D   newproj2demo.psm
   SS_wrdpts_hi     131   newproj2demo.psm
   isr              300   newproj2demo.psm
   isr_L0           30F   newproj2demo.psm
 * intvect          3FF   newproj2demo.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            102
 STAR              -

 AND              15
 OR                -
 XOR               1

 ADD              34
 ADDCY             -
 SUB               3
 SUBCY             -

 TEST              1
 TESTCY            -
 COMPARE          13
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0              16
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             9
 OUTPUT            9
 OUTPUTK           -

 STORE            12
 FETCH            12

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             24
 JUMP@             -
 CALL             23
 CALL@             -
 RETURN           23
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
