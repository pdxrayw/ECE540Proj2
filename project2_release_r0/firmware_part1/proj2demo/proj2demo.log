KCPSM6 Assembler log file for program 'C:\540_proj2\project2_release_r0\firmware_part1\proj2demo\proj2demo.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 30 Oct 2014
Assembly timestamp: 10:39:35

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3FF hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 460
Memory locations available: 3636


Assembly listing

 Addr Code                   Instruction

 000                         ; -----------------------------------------------------------------
 000                         ; proj2demo.psm - Demo program for Rojobot "world" emulator
 000                         ;
 000                         ; Version: 4.0
 000                         ; Author: Roy Kravitz
 000                         ; Date:  12-Oct-2014
 000                         ;
 000                         ; Revision History
 000                         ; ================
 000                         ; 11-Jan-07  RK  Created the first version
 000                         ; 12-Jan-09  RK  Modified for S3E Starter Board and Seven Segment Emulator
 000                         ; 16-Oct-09  RK  Minor changes (comments) for PSU ECE510
 000                         ; 24-Oct-11  RK  Minor changes (comments)
 000                         ; 24-Oct-12  RK  Modified for kcpsm6 and Nexys 3
 000                         ; 03-Jan-14  RK  Refactored as Project1 demo for ECE 540 Winter 2014 and later
 000                         ; 26-Jan-14  RK  Fixed bug in Interrupt handler.  S5 and S6 were inadvertently swapped
 000                         ;      Thanks to Jason Dutra for pointing this out.
 000                         ; 11-Oct-14  RK  Refactored as Project 2 demo for ECE 540 Fall 2014 and later.  Includes
 000                         ;      support for Nexys4 and Vivado, including a workaround for a bug in the
 000                         ;      Vivdao hardware manager (2014.2) pointed out by Ken Chapman.  The bug
 000                         ;      corrupts location 3 of the ROM so the code is written to avoid that location
 000                         ; 12-Oct-14  RK  Modified code to take advantage of the 8 digit Nexys4 (vs. 4 on the Nexys3) display
 000                         ;
 000                         ; Description:
 000                         ; ============
 000                         ; This program demonstrate the Rojobot world emulator.  It is modelled after
 000                         ; the the Verilog Rojobot implemented in the Getting Started application only this demo is based
 000                         ; on the full Rojobot emulator (as implemented in bot.v instead of the simplified
 000                         ; Rojobot model used in the Getting Started project
 000                         ;
 000                         ; The demo uses the 4 pushbuttons to control the Rojobot as follows:
 000                         ; btn_left - Left Motor forward
 000                         ;  btn_up  - Left Motor reverse
 000                         ; btn_right - Right Motor forward
 000                         ; btn_down - Right Motor reverse
 000                         ; If neither of the two buttons that control each motor is pushed, then the motor is stopped.
 000                         ; If both of the two buttons that control each motor are pushed, the actions cancel each other
 000                         ; leaving the motor stopped.
 000                         ;
 000                         ; The demo takes advantage of the wider display on the Nexys4 (8 digits vs. 4) to
 000                         ; make the rojobot state easier for follow. The digits are mapped as follows:
 000                         ; digit[7:5] - compass heading
 000                         ; digit[4] - movement (Fwd, Rev, Stopped, turning)
 000                         ; digits[2:1] - column position (X) in hex
 000                         ; digits[1:0] - row position (Y) in hex
 000                         ;
 000                         ; Decimal points 5 and 4 are turned on to highlight the movement display.  Decimal point 0 toggles
 000                         ; on and off every interrupt (~every 100 msec w/ updt_sysregs)
 000                         ; The sensors are displayed on the LEDs in both display modes.
 000                         ; Decimal point 0 toggles on and off every interrupt (~every 100 msec w/ updt_sysregs)
 000                         ;
 000                         ; NOTE:  NOT ALL THE CODE IN THIS EXAMPLE IS USED.  THE EXAMPLE WAS CREATED TO GIVE YOU, THE
 000                         ; STUDENT, AN EXAMPLE OF HOW TO CONTROL THE ROJOBOT AND NEXYS4 PERIPHERALS FROM AN EMBEDDED PICOBLAZE
 000                         ; CPU. YOU MAY (OR NOT) FIND SOME OF THIS CODE APPLICABLE TO YOUR OTHER PROJECTS
 000                         ;
 000                         ; -----------------------------------------------------------------
 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s6 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, LocX                 ; rojobot location - x coordinate
 000                         NAMEREG sE, LocY                 ; rojobot location - y coordinate
 000                         NAMEREG sD, Sensor               ; rojobot sensor values
 000                         NAMEREG sC, Botinf               ; rojobot movement and orientation values
 000                         NAMEREG sB, MVst                 ; state variable for movement indicator
 000                         ;
 000                         ; Dig7, Dig6, Dig5 and Dig4 are stored in the scratchpad
 000                         ; RAM to keep the changes to minimum
 000                         NAMEREG sA, Dig3                 ; 7-segment display digit 3
 000                         NAMEREG s9, Dig2                 ; 7-segment display digit 2
 000                         NAMEREG s8, Dig1                 ; 7-segment display digit 1
 000                         NAMEREG s7, Dig0                 ; 7-segment display digit 0
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ; Nexys 4 board base I/O interface ports compatible with the Nexys3 I/O interface
 000                         ;  Port Addresses
 000                         CONSTANT PA_PBTNS, 00            ; (i) pushbuttons inputs
 000                         CONSTANT PA_SLSWTCH, 01          ; (i) slide switches
 000                         CONSTANT PA_LEDS, 02             ; (o) LEDs
 000                         CONSTANT PA_DIG3, 03             ; (o) digit 3 port address
 000                         CONSTANT PA_DIG2, 04             ; (o) digit 2 port address
 000                         CONSTANT PA_DIG1, 05             ; (o) digit 1 port address
 000                         CONSTANT PA_DIG0, 06             ; (o) digit 0 port address
 000                         CONSTANT PA_DP, 07               ; (o) decimal points 3:0 port address
 000                         CONSTANT PA_RSVD, 08             ; (o) *RESERVED* port address
 000                         ; Rojobot interface registers
 000                         CONSTANT PA_MOTCTL_IN, 09        ; (o) Rojobot motor control output from system
 000                         CONSTANT PA_LOCX, 0A             ; (i) X coordinate of rojobot location
 000                         CONSTANT PA_LOCY, 0B             ; (i))Y coordinate of rojobot location
 000                         CONSTANT PA_BOTINFO, 0C          ; (i) Rojobot info register
 000                         CONSTANT PA_SENSORS, 0D          ; (i) Sensor register
 000                         CONSTANT PA_LMDIST, 0E           ; (i) Rojobot left motor distance register
 000                         CONSTANT PA_RMDIST, 0F           ; (i) Rojobot right motor distance register
 000                         ; Extended I/O interface port addresses for the Nexys4.  Your Nexys4_Bot interface module
 000                         ; should include these additional ports even though they are not used in this program
 000                         CONSTANT PA_PBTNS_ALT, 10        ; (i) pushbutton inputs alternate port address
 000                         CONSTANT PA_SLSWTCH1508, 11      ; (i) slide switches 15:8 (high byte of switches
 000                         CONSTANT PA_LEDS1508, 12         ; (o) LEDs 15:8 (high byte of switches)
 000                         CONSTANT PA_DIG7, 13             ; (o) digit 7 port address
 000                         CONSTANT PA_DIG6, 14             ; (o) digit 6 port address
 000                         CONSTANT PA_DIG5, 15             ; (o) digit 5 port address
 000                         CONSTANT PA_DIG4, 16             ; (o) digit 4 port address
 000                         CONSTANT PA_DP0704, 17           ; (o) decimal points 7:4 port address
 000                         CONSTANT PA_RSVD_ALT, 18         ; (o) *RESERVED* alternate port address
 000                         ; Extended Rojobot interface registers.  These are alternate Port addresses
 000                         CONSTANT PA_MOTCTL_IN_ALT, 19    ; (o) Rojobot motor control output from system
 000                         CONSTANT PA_LOCX_ALT, 1A         ; (i) X coordinate of rojobot location
 000                         CONSTANT PA_LOCY_ALT, 1B         ; (i))Y coordinate of rojobot location
 000                         CONSTANT PA_BOTINFO_ALT, 1C      ; (i) Rojobot info register
 000                         CONSTANT PA_SENSORS_ALT, 1D      ; (i) Sensor register
 000                         CONSTANT PA_LMDIST_ALT, 1E       ; (i) Rojobot left motor distance register
 000                         CONSTANT PA_RMDIST_ALT, 1F       ; (i) Rojobot right motor distance register
 000                         ; =====================================
 000                         ; === Register bit mappings (masks) ===
 000                         ; =====================================
 000                         ;  bit masks for pushbuttons and switches for seven segment emulator
 000                         CONSTANT MSK_ALLBTNS, 1F         ; Buttons are in bits[5:0]
 000                         CONSTANT MSK_PBTNS, 0F           ; Mask for 4 buttons to display on LED
 000                         CONSTANT MSK_BTN_CENTER, 10      ; Pushbutton Center is bit 4
 000                         CONSTANT MSK_BTN_LEFT, 08        ; Pushbutton Left is bit 3
 000                         CONSTANT MSK_BTN_UP, 04          ; Pushbutton Up is bit 2
 000                         CONSTANT MSK_BTN_RIGHT, 02       ; Pushbutton Right is bit 1
 000                         CONSTANT MSK_BTN_DOWN, 01        ; Pushbutton Down is bit 0
 000                         CONSTANT MSK_ALLSW_LO, FF        ; Slide switches are in bits[7:0] of PA_SLSWTCH_07_00
 000                         CONSTANT MSK_ALLSW_HI, FF        ; Slide switchees are in bits[7:0] of PA_SLSWTCH_15_08
 000                         CONSTANT MSK_SW7, 80             ; Slide switch 7 is bit 7
 000                         CONSTANT MSK_SW6, 40             ; Slide switch 6 is bit 6
 000                         CONSTANT MSK_SW5, 20             ; Slide switch 5 is bit 5
 000                         CONSTANT MSK_SW4, 10             ; Slide switch 4 is bit 4
 000                         CONSTANT MSK_SW3, 08             ; Slide switch 3 is bit 3
 000                         CONSTANT MSK_SW2, 04             ; Slide switch 2 is bit 2
 000                         CONSTANT MSK_SW1, 02             ; Slide switch 1 is bit 1
 000                         CONSTANT MSK_SW0, 01             ; Slide switch 0 is bit 0
 000                         CONSTANT MSK_SW15, 80            ; Slide switch 15 is bit 7
 000                         CONSTANT MSK_SW14, 40            ; Slide switch 14 is bit 6
 000                         CONSTANT MSK_SW13, 20            ; Slide switch 13 is bit 5
 000                         CONSTANT MSK_SW12, 10            ; Slide switch 12 is bit 4
 000                         CONSTANT MSK_SW11, 08            ; Slide switch 11 is bit 3
 000                         CONSTANT MSK_SW10, 04            ; Slide switch 10 is bit 2
 000                         CONSTANT MSK_SW09, 02            ; Slide switch 09 is bit 1
 000                         CONSTANT MSK_SW08, 01            ; Slide switch 08 is bit 0
 000                         ; bit mask for LEDs
 000                         CONSTANT MSK_LEDS_LO, FF         ; Mask for rightmost 8 LEDs on the Nexys4
 000                         CONSTANT MSK_LEDS_HI, FF         ; Mask for the lefmost 8 LEDs on the Nexys4
 000                         ; bit mask for display character codes and decimal points
 000                         CONSTANT MSK_CCODE, 1F           ; Character codes are in lower 5 bits
 000                         CONSTANT MSK_DECPTS, 0F          ; Decimal points 3 - 0 are in bits 3 to 0
 000                         CONSTANT MSK_DECPTS_HI, 0F       ; Decimal points 7-4 are in bits 3 to 0
 000                         CONSTANT MSK_HEXDIGIT, 0F        ; Hex digits only take 4 bits
 000                         ; nibble masks
 000                         CONSTANT MSKLOWNIB, 0F           ; Mask out high nibble of byte
 000                         CONSTANT MSKHIGHNIB, F0          ; Mask out low nibble of byte
 000                         CONSTANT INVLOWNIB, 0F           ; Invert low nibble of byte
 000                         ; =============================
 000                         ; === Useful Data Constants ===
 000                         ; =============================
 000                         ;  Constants for True and False and Null
 000                         CONSTANT FALSE, 00
 000                         CONSTANT TRUE, 01
 000                         CONSTANT NULL, 00
 000                         ; Character code table for special characters
 000                         ; Decimal digits 0 to 15 display '0'to 'F'
 000                         CONSTANT CC_BASE, 10             ; Base value for special characters
 000                         CONSTANT CC_SEGBASE, 10          ; Base value for segment display special characters
 000                         ;     abcdefg
 000                         CONSTANT CC_SEGA, 10             ; Segment A  [1000000]
 000                         CONSTANT CC_SEGB, 11             ; Segment B  [0100000]
 000                         CONSTANT CC_SEGC, 12             ; Segment C  [0010000]
 000                         CONSTANT CC_SEGD, 13             ; Segment D  [0001000]
 000                         CONSTANT CC_SEGE, 14             ; Segment E  [0000100]
 000                         CONSTANT CC_SEGF, 15             ; Segment F  [0000010]
 000                         CONSTANT CC_SEGG, 16             ; Segment G  [0000001]
 000                         CONSTANT CC_DOT, 17              ; Dot (period)
 000                         CONSTANT CC_UCH, 18              ; Upper Case H
 000                         CONSTANT CC_UCL, 19              ; Upper Case L
 000                         CONSTANT CC_UCR, 1A              ; Upper Case R
 000                         CONSTANT CC_LCL, 1B              ; Lower Case L
 000                         CONSTANT CC_LCR, 1C              ; Lower Case R
 000                         CONSTANT CC_SPACE1, 1D           ; Space (blank)
 000                         CONSTANT CC_SPACE2, 1E           ; Space (blank)
 000                         CONSTANT CC_SPACE, 1F            ; Space (blank)
 000                         ; ======================
 000                         ; === BotInfo values ===
 000                         ; ======================
 000                         CONSTANT OR_N, 00                ; Orientation is North
 000                         CONSTANT OR_NE, 01               ; Orientation is Northeast
 000                         CONSTANT OR_E, 02                ; Orientation is East
 000                         CONSTANT OR_SE, 03               ; Orientation is Southeast
 000                         CONSTANT OR_S, 04                ; Orientation is South
 000                         CONSTANT OR_SW, 05               ; Orientation is Southwest
 000                         CONSTANT OR_W, 06                ; Orientation is West
 000                         CONSTANT OR_NW, 07               ; Orientation is Northwest
 000                         CONSTANT MV_STOP, 00             ; Movement is stopped
 000                         CONSTANT MV_FWD, 04              ; Movement is forward
 000                         CONSTANT MV_REV, 08              ; Movement is reverse
 000                         CONSTANT MV_SLT, 0C              ; Movement is slow left turn
 000                         CONSTANT MV_FLT, 0D              ; Movement is fast left turn
 000                         CONSTANT MV_SRT, 0E              ; Movement is slow right turn
 000                         CONSTANT MV_FRT, 0F              ; Movement is fast right turn
 000                         ; Next 2 contants assume field is in low nibble
 000                         CONSTANT MSKMVMT, 0F             ; Mask out all but movement bits
 000                         CONSTANT MSKORIENT, 07           ; Mask out all but orientation bits
 000                         ; =================================
 000                         ; === Scratch Pad RAM Variables ===
 000                         ; =================================
 000                         ; Pushbutton translation lookup table.  Converts pushbutton combos
 000                         ; to Motor Control input register format [lmspd[2:0],lmdir,rmspd[2:0],rmdir]
 000                         CONSTANT SP_BTNBASE, 00          ; table is based at 0x00
 000                         ;        [b3,b2,b1,b0]=[lf,lr,rf,rr]
 000                         CONSTANT SP_LSRS, 00             ; left motor off, right motor off     [0000]
 000                         CONSTANT SP_LORR, 02             ; left motor off, right motor reverse   [0001]
 000                         CONSTANT SP_LSRF, 03             ; left motor off, right motor forward   [0010]
 000                         CONSTANT SP_LSRFR, 00            ; left motor off, right motor fwd & rev = off [0011]
 000                         CONSTANT SP_LRRS, 20             ; left motor reverse, right motor off   [0100]
 000                         CONSTANT SP_LRRR, 22             ; left motor reverse, right motor reverse  [0101]
 000                         CONSTANT SP_LRRF, 23             ; left motor reverse, right motor forward  [0110]
 000                         CONSTANT SP_LRRFR, 20            ; left motor rev, right motor fwd & rev = off [0111]
 000                         CONSTANT SP_LFRS, 30             ; left motor forward, right motor off    [1000]
 000                         CONSTANT SP_LFRR, 32             ; left motor forward, right motor reverse  [1001]
 000                         CONSTANT SP_LFRF, 33             ; left motor forward, right motor forward  [1010]
 000                         CONSTANT SP_LFRFR, 30            ; left motor fwd, right motor fwd & rev = off [1011]
 000                         CONSTANT SP_LFRRS, 00            ; left motor fwd & rev = off, right motor off [1100]
 000                         CONSTANT SP_LFRRR, 02            ; left motor fwd & rev = off, right motor rev [1101]
 000                         CONSTANT SP_LFRRF, 03            ; left motor fwd & rev = off, right motor fwd [1110]
 000                         CONSTANT SP_LFRRFR, 00           ; left  and right motor fwd & rev = off   [1111]
 000                         ; Movement display lookup table.  Converts movement from BotInfo register to
 000                         ; the character code to display.  Not very dense but we have the room in the SP RAM and
 000                         ; it saves building a switch statement into the code.
 000                         CONSTANT SP_MVMTBASE, 10         ; table is based at 0x10
 000                         CONSTANT SP_MVMT0, 18            ; Stopped - display upper case H
 000                         CONSTANT SP_MVMT1, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT2, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT3, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT4, 0F            ; Forward - display upper case F
 000                         CONSTANT SP_MVMT5, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT6, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT7, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMT8, 0B            ; Reverse (Backward) - display lower case B
 000                         CONSTANT SP_MVMT9, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTA, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTB, 17            ; Reserved - display dot to indicate error
 000                         CONSTANT SP_MVMTC, 19            ; Slow left turn - display upper case L
 000                         CONSTANT SP_MVMTD, 1B            ; Fast left turn - display lower case L
 000                         CONSTANT SP_MVMTE, 1A            ; Slow right turn - display upper case R
 000                         CONSTANT SP_MVMTF, 1C            ; Fast right turn - display lower case R
 000                         ; ==============================
 000                         ; === Storage for old values ===
 000                         ; ==============================
 000                         CONSTANT SP_SEM, 20              ; Semaphore between isr and main loop
 000                         CONSTANT SP_TEMP1, 21            ; Temp storage.  Used by ISR
 000                         CONSTANT SP_TEMP2, 22            ;
 000                         CONSTANT SP_LMDIST, 23           ; Storage for left and right motor distance counters
 000                         CONSTANT SP_RMDIST, 24           ;
 000                         CONSTANT SP_OLDMVMT, 25          ; Old movement value
 000                         CONSTANT SP_OLDHDG, 26           ; Old heading value
 000                         CONSTANT SP_OLDDP, 27            ; Old decimal points
 000                         ; =========================
 000                         ; === Digits 7, 6, 5, 4 ===
 000                         ;==========================
 000                         CONSTANT SP_DIG7, 30             ; Digit[7:4] contain the BOT heading
 000                         CONSTANT SP_DIG6, 31             ;
 000                         CONSTANT SP_DIG5, 32             ;
 000                         CONSTANT SP_DIG4, 33             ;
 000                         ;==========================
 000                         ;====Scratch pads variables for find line
 000                         ;==========================
 000                         CONSTANT SP_STOP, 34             ; stop variable
 000                         CONSTANT SP_REV_T, 35            ;
 000                         CONSTANT SP_REV_C, 36            ;
 000                         CONSTANT SP_RT_T, 37             ;
 000                         CONSTANT SP_RT_C, 38             ;
 000                         CONSTANT SP_RLOCX, 39            ;
 000                         CONSTANT SP_RLOCY, 40            ;
 000                         CONSTANT SP_RORT, 41             ;
 000                         CONSTANT SP_FIND, 42             ;
 000                         CONSTANT SP_ORT, 43              ;
 000                         CONSTANT SP_RT_COMP, 44          ;
 000                         CONSTANT SP_ORT_T, 45            ;
 000                         CONSTANT SP_ORT_C, 46            ;
 000                         CONSTANT SP_RTS, 47              ;
 000                         ; ===============
 000                         ; === main()  ===
 000                         ; ===============
 000                         ADDRESS 000
 000  22004                  JUMP 004[main]                   ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                   ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                   ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                   ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004  20036            main: CALL 036[init_btnluptbl]         ; initialize button to MotCtl lookup table
 005  2006D                  CALL 06D[init_mvmttbl]           ; initialize movement to character code lookup table
 006  2009E                  CALL 09E[init_find_line]         ; initialize find line variables
 007  01100                  LOAD s1, 00                      ; clear the semaphore
 008  2F120                  STORE s1, 20[SP_SEM]             ;
 009  01100                  LOAD s1, 00                      ; turn off decimal points 3-0.  Decimal point 0 (rightmost
 00A  2F127                  STORE s1, 27[SP_OLDDP]           ; and save the value
 00B  201AD                  CALL 1AD[SS_wrdpts]              ; will be toggled in the interrupt handler
 00C  01103                  LOAD s1, 03                      ; turn on decimal points 5 and 4 to offset the movement digit
 00D  201B1                  CALL 1B1[SS_wrdpts_hi]           ; we don't need to save this value because these decimal points don't change
 00E  28001                  ENABLE INTERRUPT                 ; get the ball rolling
 00F                         ; ==================
 00F                         ; === Main  Loop ===
 00F                         ; ==================
 00F                         ; while(1) {  // main loop is an infinite loop
 00F  0B620         main_L0: FETCH s6, 20[SP_SEM]             ;  while (SP_SEMA == 0)  {}   // loop until isr updates rojobot registers
 010  1D600                  COMPARE s6, 00                   ;
 011  3200F                  JUMP Z, 00F[main_L0]             ;
 012  200EF                  CALL 0EF[next_loc]               ;   Dig[3:2] = nex LocX; Dig[1:0] = next LocY
 013  200B4                  CALL 0B4[next_mvmt]              ;   Dig[4] = next movement
 014  200BC                  CALL 0BC[next_hdg]               ;   Dig[7:4] = next heading
 015                         ;  }
 015  2001D         main_L2: CALL 01D[wr_alldigits]           ;  write all of the digits to the display
 016  001D0                  LOAD s1, sD[Sensor]              ;  update LEDs with new sensor information
 017  2018F                  CALL 18F[LED_wrleds]             ;
 018  20102                  CALL 102[find_line]              ; tell rojobot to move
 019  0B620                  FETCH s6, 20[SP_SEM]
 01A  19601                  SUB s6, 01                       ;  decrement semaphore
 01B  2F620                  STORE s6, 20[SP_SEM]             ;
 01C  2200F                  JUMP 00F[main_L0]                ; } // end - main while loop
 01D                         ;**************************************************************************************
 01D                         ; Support functions
 01D                         ;**************************************************************************************
 01D                         ; ===============================================================================
 01D                         ; === wr_alldigits() - Writes all 8 display digits from the global locations  ===
 01D                         ; === Registers used s0,s1,s2, Dig0, Dig1, Dig2, Dig3                         ===
 01D                         ; --- Scratchpad RAM locations used SP_DIG4, SP_DIG5, SP_DIG6, SP_DIG7        ===
 01D                         ; ===============================================================================
 01D           wr_alldigits: ; Digits 0 to 3 are stored in registers
 01D                         ; and written to the didsplay with SS_wdigx()
 01D  01200                  LOAD s2, 00                      ; point at digit 0
 01E  00170                  LOAD s1, s7[Dig0]                ; and write it to display
 01F  20197                  CALL 197[SS_wrdigx]              ;
 020  01201                  LOAD s2, 01                      ; point at digit 1
 021  00180                  LOAD s1, s8[Dig1]                ; and write it to display
 022  20197                  CALL 197[SS_wrdigx]              ;
 023  01202                  LOAD s2, 02                      ; point at digit 2
 024  00190                  LOAD s1, s9[Dig2]                ; and write it to display
 025  20197                  CALL 197[SS_wrdigx]              ;
 026  01203                  LOAD s2, 03                      ; point at digit 3
 027  001A0                  LOAD s1, sA[Dig3]                ; and write it to the display
 028  20197                  CALL 197[SS_wrdigx]              ;
 029                         ; Digits 4 to 7 are stored in the Scratchpad RAM
 029                         ; and written to the display with SS_wdigx_hi()
 029  01204                  LOAD s2, 04                      ; point at digit 4
 02A  0B133                  FETCH s1, 33[SP_DIG4]            ; and write it to the display
 02B  201A0                  CALL 1A0[SS_wrdigx_hi]           ;
 02C  01205                  LOAD s2, 05                      ; point at digit 5
 02D  0B132                  FETCH s1, 32[SP_DIG5]            ; and write it to the display
 02E  201A0                  CALL 1A0[SS_wrdigx_hi]           ;
 02F  01206                  LOAD s2, 06                      ; point at digit 6
 030  0B131                  FETCH s1, 31[SP_DIG6]            ; and write it to the display
 031  201A0                  CALL 1A0[SS_wrdigx_hi]           ;
 032  01207                  LOAD s2, 07                      ; point at digit 7
 033  0B130                  FETCH s1, 30[SP_DIG7]            ; and write it to the display
 034  201A0                  CALL 1A0[SS_wrdigx_hi]           ;
 035  25000                  RETURN 
 036                         ;*******
 036                         ; Functions to convert pushbutton presses to Motor Control input
 036                         ;*******
 036                         ; ===============================================================================
 036                         ; === init_btnluptbl() - initialize button translation lookup table in SP RAM ===
 036                         ; === Registers affected: s0, s1                                              ===
 036                         ; ===============================================================================
 036  01000  init_btnluptbl: LOAD s0, 00[SP_BTNBASE]          ; s0 gets base of button translation lookup table
 037  01100                  LOAD s1, 00[SP_LSRS]             ; s1 gets values for 0x00
 038  2E100                  STORE s1, (s0)                   ; store the entry in the table
 039  11001                  ADD s0, 01                       ; increment the table index
 03A  01102                  LOAD s1, 02[SP_LORR]             ; s1 gets values for 0x01
 03B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03C  11001                  ADD s0, 01                       ; increment the table index
 03D  01103                  LOAD s1, 03[SP_LSRF]             ; s1 gets values for 0x02
 03E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 03F  11001                  ADD s0, 01                       ; increment the table index
 040  01100                  LOAD s1, 00[SP_LSRFR]            ; s1 gets values for 0x03
 041  2E100                  STORE s1, (s0)                   ; store the entry in the table
 042  11001                  ADD s0, 01                       ; increment the table index
 043  01120                  LOAD s1, 20[SP_LRRS]             ; s1 gets values for 0x04
 044  2E100                  STORE s1, (s0)                   ; store the entry in the table
 045  11001                  ADD s0, 01                       ; increment the table index
 046  01122                  LOAD s1, 22[SP_LRRR]             ; s1 gets values for 0x05
 047  2E100                  STORE s1, (s0)                   ; store the entry in the table
 048  11001                  ADD s0, 01                       ; increment the table index
 049  01123                  LOAD s1, 23[SP_LRRF]             ; s1 gets values for 0x06
 04A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04B  11001                  ADD s0, 01                       ; increment the table index
 04C  01120                  LOAD s1, 20[SP_LRRFR]            ; s1 gets values for 0x07
 04D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 04E  11001                  ADD s0, 01                       ; increment the table index
 04F  01130                  LOAD s1, 30[SP_LFRS]             ; s1 gets values for 0x08
 050  2E100                  STORE s1, (s0)                   ; store the entry in the table
 051  11001                  ADD s0, 01                       ; increment the table index
 052  01132                  LOAD s1, 32[SP_LFRR]             ; s1 gets values for 0x09
 053  2E100                  STORE s1, (s0)                   ; store the entry in the table
 054  11001                  ADD s0, 01                       ; increment the table index
 055  01133                  LOAD s1, 33[SP_LFRF]             ; s1 gets values for 0x0A
 056  2E100                  STORE s1, (s0)                   ; store the entry in the table
 057  11001                  ADD s0, 01                       ; increment the table index
 058  01130                  LOAD s1, 30[SP_LFRFR]            ; s1 gets values for 0x0B
 059  2E100                  STORE s1, (s0)                   ; store the entry in the table
 05A  11001                  ADD s0, 01                       ; increment the table index
 05B  01100                  LOAD s1, 00[SP_LFRRS]            ; s1 gets values for 0x0C
 05C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 05D  11001                  ADD s0, 01                       ; increment the table index
 05E  01102                  LOAD s1, 02[SP_LFRRR]            ; s1 gets values for 0x0D
 05F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 060  11001                  ADD s0, 01                       ; increment the table index
 061  01103                  LOAD s1, 03[SP_LFRRF]            ; s1 gets values for 0x0E
 062  2E100                  STORE s1, (s0)                   ; store the entry in the table
 063  11001                  ADD s0, 01                       ; increment the table index
 064  01100                  LOAD s1, 00[SP_LFRRFR]           ; s1 gets values for 0x0F
 065  2E100                  STORE s1, (s0)                   ; store the entry in the table
 066  25000                  RETURN                           ; done...at last
 067                         ; =============================================================================
 067                         ; === btn2mot() - Button to MotCtl conversion function                      ===
 067                         ; === Registers affected: s1, s2                                            ===
 067                         ; === s0 contains the button value to convert.                              ===
 067                         ; === Result (Motor Control register value) is returned in s1               ===
 067                         ; === s0 (Button value) is not changed                                      ===
 067                         ; =============================================================================
 067  01200         btn2mot: LOAD s2, 00[SP_BTNBASE]          ; s2 gets base of button conversion table
 068  00100                  LOAD s1, s0                      ; mask out upper nibble of buttons
 069  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 06A  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 06B  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 06C  25000                  RETURN 
 06D                         ; ===============================================================================
 06D                         ; === init_mvmttbl() - initialize movement translation lookup table in SP RAM ===
 06D                         ; === Registers affected: s0, s1                                              ===
 06D                         ; ===============================================================================
 06D  01010    init_mvmttbl: LOAD s0, 10[SP_MVMTBASE]         ; s0 gets base of movement translation lookup table
 06E  01118                  LOAD s1, 18[SP_MVMT0]            ; s1 gets values for 0x00
 06F  2E100                  STORE s1, (s0)                   ; store the entry in the table
 070  11001                  ADD s0, 01                       ; increment the table index
 071  01117                  LOAD s1, 17[SP_MVMT1]            ; s1 gets values for 0x01
 072  2E100                  STORE s1, (s0)                   ; store the entry in the table
 073  11001                  ADD s0, 01                       ; increment the table index
 074  01117                  LOAD s1, 17[SP_MVMT2]            ; s1 gets values for 0x02
 075  2E100                  STORE s1, (s0)                   ; store the entry in the table
 076  11001                  ADD s0, 01                       ; increment the table index
 077  01117                  LOAD s1, 17[SP_MVMT3]            ; s1 gets values for 0x03
 078  2E100                  STORE s1, (s0)                   ; store the entry in the table
 079  11001                  ADD s0, 01                       ; increment the table index
 07A  0110F                  LOAD s1, 0F[SP_MVMT4]            ; s1 gets values for 0x04
 07B  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07C  11001                  ADD s0, 01                       ; increment the table index
 07D  01117                  LOAD s1, 17[SP_MVMT5]            ; s1 gets values for 0x05
 07E  2E100                  STORE s1, (s0)                   ; store the entry in the table
 07F  11001                  ADD s0, 01                       ; increment the table index
 080  01117                  LOAD s1, 17[SP_MVMT6]            ; s1 gets values for 0x06
 081  2E100                  STORE s1, (s0)                   ; store the entry in the table
 082  11001                  ADD s0, 01                       ; increment the table index
 083  01117                  LOAD s1, 17[SP_MVMT7]            ; s1 gets values for 0x07
 084  2E100                  STORE s1, (s0)                   ; store the entry in the table
 085  11001                  ADD s0, 01                       ; increment the table index
 086  0110B                  LOAD s1, 0B[SP_MVMT8]            ; s1 gets values for 0x08
 087  2E100                  STORE s1, (s0)                   ; store the entry in the table
 088  11001                  ADD s0, 01                       ; increment the table index
 089  01117                  LOAD s1, 17[SP_MVMT9]            ; s1 gets values for 0x09
 08A  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08B  11001                  ADD s0, 01                       ; increment the table index
 08C  01117                  LOAD s1, 17[SP_MVMTA]            ; s1 gets values for 0x0A
 08D  2E100                  STORE s1, (s0)                   ; store the entry in the table
 08E  11001                  ADD s0, 01                       ; increment the table index
 08F  01117                  LOAD s1, 17[SP_MVMTB]            ; s1 gets values for 0x0B
 090  2E100                  STORE s1, (s0)                   ; store the entry in the table
 091  11001                  ADD s0, 01                       ; increment the table index
 092  01119                  LOAD s1, 19[SP_MVMTC]            ; s1 gets values for 0x0C
 093  2E100                  STORE s1, (s0)                   ; store the entry in the table
 094  11001                  ADD s0, 01                       ; increment the table index
 095  0111B                  LOAD s1, 1B[SP_MVMTD]            ; s1 gets values for 0x0D
 096  2E100                  STORE s1, (s0)                   ; store the entry in the table
 097  11001                  ADD s0, 01                       ; increment the table index
 098  0111A                  LOAD s1, 1A[SP_MVMTE]            ; s1 gets values for 0x0E
 099  2E100                  STORE s1, (s0)                   ; store the entry in the table
 09A  11001                  ADD s0, 01                       ; increment the table index
 09B  0111C                  LOAD s1, 1C[SP_MVMTF]            ; s1 gets values for 0x0F
 09C  2E100                  STORE s1, (s0)                   ; store the entry in the table
 09D  25000                  RETURN                           ; done...at last
 09E                         ; ===============================================================================
 09E                         ; === init_find_line() - initialize find line scratch pad variables ===
 09E                         ; === Registers affected: s0, s1                                              ===
 09E                         ; ===============================================================================
 09E         init_find_line: 
 09E  01000                  LOAD s0, 00
 09F  2F034                  STORE s0, 34[SP_STOP]
 0A0  2F035                  STORE s0, 35[SP_REV_T]
 0A1  2F036                  STORE s0, 36[SP_REV_C]
 0A2  2F037                  STORE s0, 37[SP_RT_T]
 0A3  2F038                  STORE s0, 38[SP_RT_C]
 0A4  2F039                  STORE s0, 39[SP_RLOCX]
 0A5  2F040                  STORE s0, 40[SP_RLOCY]
 0A6  2F041                  STORE s0, 41[SP_RORT]
 0A7  2F042                  STORE s0, 42[SP_FIND]
 0A8  2F043                  STORE s0, 43[SP_ORT]
 0A9  2F044                  STORE s0, 44[SP_RT_COMP]
 0AA  2F045                  STORE s0, 45[SP_ORT_T]
 0AB  2F046                  STORE s0, 46[SP_ORT_C]
 0AC  2F047                  STORE s0, 47[SP_RTS]
 0AD  25000                  RETURN 
 0AE                         ; =============================================================================
 0AE                         ; === mvmt2cc() - movement to character code conversion function            ===
 0AE                         ; === Registers affected: s1, s2                                            ===
 0AE                         ; === s0 contains the movment value to convert.                             ===
 0AE                         ; === Result (character code to display) is returned in s1                  ===
 0AE                         ; === s0 (movement) is not changed                                          ===
 0AE                         ; =============================================================================
 0AE  01210         mvmt2cc: LOAD s2, 10[SP_MVMTBASE]         ; s2 gets base of movment conversion table
 0AF  00100                  LOAD s1, s0                      ; mask out upper nibble of movment
 0B0  0310F                  AND s1, 0F[MSKLOWNIB]            ;
 0B1  10210                  ADD s2, s1                       ; s2 = Base + offset into table
 0B2  0A120                  FETCH s1, (s2)                   ; and fetch the entry
 0B3  25000                  RETURN 
 0B4                         ;#########################################
 0B4                         ; Modify this function for Project 2 #####
 0B4                         ;#########################################
 0B4                         ; ========================================================================
 0B4                         ; === next_mvmt() - Calculate  digit for motion indicator              ===
 0B4                         ; === Registers affected: Dig3, s0                                     ===
 0B4                         ; === Uses Botinf (Bot Info register) to get movement.                 ===
 0B4                         ; ========================================================================
 0B4  000C0       next_mvmt: LOAD s0, sC[Botinf]              ; s0[3:0] = Botinf[7:4]
 0B5  1400E                  SR0 s0                           ;
 0B6  1400E                  SR0 s0                           ;
 0B7  1400E                  SR0 s0                           ;
 0B8  1400E                  SR0 s0                           ;
 0B9  200AE                  CALL 0AE[mvmt2cc]                ; translate movement to char code
 0BA  2F133                  STORE s1, 33[SP_DIG4]            ; and move to digit 4.
 0BB  25000                  RETURN                           ; digit 4 is in the scratchpad RAM
 0BC                         ; ==============================================================================
 0BC                         ; === next_hdg() - Calculate  digits for heading (compass setting)           ===
 0BC                         ; === Registers affected: Dig2, Dig1, Dig0, s0, s1, s2, s3,s4, s5, s6        ===
 0BC                         ; === Uses Botinf (Bot Info register) to get orientation.  Calculates digits ===
 0BC                         ; === with a case statement based on orientation.                            ===
 0BC                         ; ==============================================================================
 0BC  000C0        next_hdg: LOAD s0, sC[Botinf]              ; s0[2:0] = Botinf[2:0] = orientation
 0BD  03007                  AND s0, 07[MSKORIENT]            ;
 0BE                         ; switch(orientation)  {
 0BE  1D000      nh_caseORN: COMPARE s0, 00[OR_N]             ; case(OR_N):
 0BF  360C4                  JUMP NZ, 0C4[nh_caseORNE]        ;
 0C0  01400                  LOAD s4, 00                      ;  Dig[2:0] = 000
 0C1  01500                  LOAD s5, 00                      ;
 0C2  01600                  LOAD s6, 00                      ;
 0C3  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0C4                         ;
 0C4  1D001     nh_caseORNE: COMPARE s0, 01[OR_NE]            ; case (OR_NE):
 0C5  360CA                  JUMP NZ, 0CA[nh_caseORE]         ;
 0C6  01400                  LOAD s4, 00                      ;  Dig[2:0] = 045
 0C7  01504                  LOAD s5, 04                      ;
 0C8  01605                  LOAD s6, 05                      ;
 0C9  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0CA  1D002      nh_caseORE: COMPARE s0, 02[OR_E]             ; case (OR_E):
 0CB  360D0                  JUMP NZ, 0D0[nh_caseORSE]        ;
 0CC  01400                  LOAD s4, 00                      ;  Dig[2:0] = 090
 0CD  01509                  LOAD s5, 09                      ;
 0CE  01600                  LOAD s6, 00                      ;
 0CF  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0D0  1D003     nh_caseORSE: COMPARE s0, 03[OR_SE]            ; case (OR_SE):
 0D1  360D6                  JUMP NZ, 0D6[nh_caseORS]         ;
 0D2  01401                  LOAD s4, 01                      ;  Dig[2:0] = 135
 0D3  01503                  LOAD s5, 03                      ;
 0D4  01605                  LOAD s6, 05                      ;
 0D5  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0D6  1D004      nh_caseORS: COMPARE s0, 04[OR_S]             ; case (OR_S):
 0D7  360DC                  JUMP NZ, 0DC[nh_caseORSW]        ;
 0D8  01401                  LOAD s4, 01                      ;  Dig[2:0] = 180
 0D9  01508                  LOAD s5, 08                      ;
 0DA  01600                  LOAD s6, 00                      ;
 0DB  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0DC  1D005     nh_caseORSW: COMPARE s0, 05[OR_SW]            ; case (OR_SW):
 0DD  360E2                  JUMP NZ, 0E2[nh_caseORW]         ;
 0DE  01402                  LOAD s4, 02                      ;  Dig[2:0] = 225
 0DF  01502                  LOAD s5, 02                      ;
 0E0  01605                  LOAD s6, 05                      ;
 0E1  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0E2  1D006      nh_caseORW: COMPARE s0, 06[OR_W]             ; case (OR_W):
 0E3  360E8                  JUMP NZ, 0E8[nh_caseORNW]        ;
 0E4  01402                  LOAD s4, 02                      ;  Dig[2:0] = 270
 0E5  01507                  LOAD s5, 07                      ;
 0E6  01600                  LOAD s6, 00                      ;
 0E7  220EB                  JUMP 0EB[nh_endcase]             ;  break;
 0E8                         ; case (OR_NW):  // only remaining case
 0E8  01403     nh_caseORNW: LOAD s4, 03                      ;  Dig[2:0] = 315
 0E9  01501                  LOAD s5, 01                      ;
 0EA  01605                  LOAD s6, 05                      ;
 0EB                         ; } // end of switch statement
 0EB  2F430      nh_endcase: STORE s4, 30[SP_DIG7]            ; update the heading display digits
 0EC  2F531                  STORE s5, 31[SP_DIG6]            ; these are stored in the Scratchpad RAM
 0ED  2F632                  STORE s6, 32[SP_DIG5]            ;
 0EE  25000                  RETURN 
 0EF                         ; ==============================================================================
 0EF                         ; === next_loc() - Calculate digits for Rojobot location                     ===
 0EF                         ; === Registers affected: Dig3, Dig2, Dig1, Dig0, s0                         ===
 0EF                         ; === Uses LocX and LocY to get location.                                    ===
 0EF                         ; ==============================================================================
 0EF  000F0        next_loc: LOAD s0, sF[LocX]                ; Dig[3:2] gets X-coordinate
 0F0  00900                  LOAD s9[Dig2], s0                ; Digit 2 gets lower nibble
 0F1  0390F                  AND s9[Dig2], 0F[MSK_HEXDIGIT]   ;
 0F2  1400E                  SR0 s0                           ; Digit3 gets upper nibble
 0F3  1400E                  SR0 s0                           ;
 0F4  1400E                  SR0 s0                           ;
 0F5  1400E                  SR0 s0                           ;
 0F6  00A00                  LOAD sA[Dig3], s0                ;
 0F7  000E0                  LOAD s0, sE[LocY]                ; Dig[1:0] gets Y-coordinate
 0F8  00700                  LOAD s7[Dig0], s0                ; Digit 0 gets lower nibble
 0F9  0370F                  AND s7[Dig0], 0F[MSK_HEXDIGIT]   ;
 0FA  1400E                  SR0 s0                           ; Digit 1 gets upper nibble
 0FB  1400E                  SR0 s0                           ;
 0FC  1400E                  SR0 s0                           ;
 0FD  1400E                  SR0 s0                           ;
 0FE  00800                  LOAD s8[Dig1], s0                ;
 0FF  25000                  RETURN 
 100                         ;#########################################
 100                         ; Modify this function for Project 2 #####
 100                         ;#########################################
 100                         ; ==============================================================================
 100                         ; === next_step() - Tells rojobot what to do next                            ===
 100                         ; === Registers affected: s0, s1                                             ===
 100                         ; === This version reads the pushbuttons, calculates the new Motor Control   ===
 100                         ; === register value and then writes MotCtl so Rojobot knows what to do      ===
 100                         ; ==============================================================================
 100              next_step: ;CALL  DEB_rdbtns     ; Read the pushbuttons. buttons returned in s0
 100  20102                  CALL 102[find_line]              ; See if the line is under the bot. returns movement needed in s0
 101                         ;CALL  btn2mot      ; and calculate new MotCtl - returned in s1
 101                         ;OUTPUT s1,  PA_MOTCTL_IN  ; tell Rojobot what to do
 101  25000                  RETURN 
 102  0B142       find_line: FETCH s1, 42[SP_FIND]            ;get variable
 103  1D100                  COMPARE s1, 00                   ;check to see if find is complete
 104  3611D                  JUMP NZ, 11D[stop]               ; if find is complete go to stop
 105  01100                  LOAD s1, 00
 106  2F134                  STORE s1, 34[SP_STOP]            ;make sure that we can go to stop
 107  003C0                  LOAD s3, sC[Botinf]              ;read the botinfo into s3: s3[3:0] = Botinf[7:4]
 108  1430E                  SR0 s3                           ; this will get the movement speed
 109  1430E                  SR0 s3                           ;
 10A  1430E                  SR0 s3                           ;
 10B  1430E                  SR0 s3                           ;
 10C  001D0                  LOAD s1, sD[Sensor]              ;read the sensor into s1
 10D  00410                  LOAD s4, s1                      ; load sensor info into s4
 10E  03407                  AND s4, 07                       ;mask out unused bits (00000111 = 7 hex)
 10F  1D400                  COMPARE s4, 00                   ;check to see if the line is there
 110  3611D                  JUMP NZ, 11D[stop]               ;if line is not there stop
 111  0B147                  FETCH s1, 47[SP_RTS]             ;see if right turn has started
 112  1D100                  COMPARE s1, 00
 113  34165                  CALL NZ, 165[clean_up2]          ;if right turn has started and the line was found clean up all variables
 114  001D0                  LOAD s1, sD[Sensor]              ;read the sensor into s1
 115  00410                  LOAD s4, s1                      ;load sensor info into s4
 116  03418                  AND s4, 18                       ;mask out unused bits (00011000 = 18 hex)
 117  1D418                  COMPARE s4, 18                   ;check to see if the wall is there
 118  32183                  JUMP Z, 183[end1]
 119  2F146                  STORE s1, 46[SP_ORT_C]           ;set flag that the orientation is complete
 11A  01033                  LOAD s0, 33                      ;make bot go forward 00110011 = 33 hex (forward)
 11B                         ; 00 hex = stop
 11B                         ; 22 hex = backward
 11B                         ;30 hex = slow right turn
 11B                         ;03 hex = slow left turn
 11B  2D009                  OUTPUT s0, 09[PA_MOTCTL_IN]      ;tell Rojobot to go forward
 11C  25000                  RETURN                           ;if bot moved go back to main
 11D  01101            stop: LOAD s1, 01
 11E  2F142                  STORE s1, 42[SP_FIND]            ;make sure that find flag is set
 11F  0B134                  FETCH s1, 34[SP_STOP]            ;get variable that tells if stop has completed
 120  1D100                  COMPARE s1, 00                   ;check to see if stop is complete
 121  3612F                  JUMP NZ, 12F[reverse]            ; if stop is complete go to reverse
 122  01100                  LOAD s1, 00
 123  2F135                  STORE s1, 35[SP_REV_T]           ;make sure that we can go to reverse
 124  2F136                  STORE s1, 36[SP_REV_C]           ;make sure reverse is not flagged as complete
 125  003C0                  LOAD s3, sC[Botinf]              ;read the botinfo into s3: s3[3:0] = Botinf[7:4]
 126  1430E                  SR0 s3                           ; this will get the movement speed
 127  1430E                  SR0 s3                           ;
 128  1430E                  SR0 s3                           ;
 129  1430E                  SR0 s3                           ;
 12A  1D300                  COMPARE s3, 00                   ; check if botinfo shows bot as stopped
 12B  3212F                  JUMP Z, 12F[reverse]             ; if bot is stopped go to reverse
 12C  01100                  LOAD s1, 00                      ; load stop into s1
 12D  2D109                  OUTPUT s1, 09[PA_MOTCTL_IN]      ; tell Rojobot what to do
 12E  25000                  RETURN 
 12F  01101         reverse: LOAD s1, 01
 130  2F134                  STORE s1, 34[SP_STOP]            ;make sure that stop flag is set
 131  0B135                  FETCH s1, 35[SP_REV_T]           ; get value from reverse toggle
 132  1D100                  COMPARE s1, 00                   ; check if this is the first time in this loop
 133  3613B                  JUMP NZ, 13B[reverse2]           ; if not, go to reverse 2 loop
 134  01100                  LOAD s1, 00
 135  2F145                  STORE s1, 45[SP_ORT_T]           ;make sure that we can go to right turn
 136  2F146                  STORE s1, 46[SP_ORT_C]           ;make sure that right turn flag is not marked complete
 137  2FF39                  STORE sF[LocX], 39[SP_RLOCX]     ; put the current location X in the SP
 138  2FE40                  STORE sE[LocY], 40[SP_RLOCY]     ; put the current Y location in the SP
 139  01101                  LOAD s1, 01
 13A  2F135                  STORE s1, 35[SP_REV_T]           ; set reverse toggle flag
 13B  0B136        reverse2: FETCH s1, 36[SP_REV_C]           ; get value from reverse complete
 13C  1D100                  COMPARE s1, 00                   ; check if reverse is complete
 13D  36147                  JUMP NZ, 147[right_turn]         ; if yes, go to right turn loop
 13E  0B039                  FETCH s0, 39[SP_RLOCX]           ;load the old value of locx
 13F  0B140                  FETCH s1, 40[SP_RLOCY]           ; load the old value of locy
 140  1C0F0                  COMPARE s0, sF[LocX]             ; see if the x has moved
 141  36147                  JUMP NZ, 147[right_turn]
 142  1C1E0                  COMPARE s1, sE[LocY]             ;see if the y has moved
 143  36147                  JUMP NZ, 147[right_turn]
 144  01022                  LOAD s0, 22                      ;make bot go reverse 00100010 = 22 hex (reverse)
 145  2D009                  OUTPUT s0, 09[PA_MOTCTL_IN]      ;tell Rojobot to go reverse
 146  25000                  RETURN 
 147  01101      right_turn: LOAD s1, 01
 148  2F135                  STORE s1, 35[SP_REV_T]           ;make sure that reverse flag is set
 149  2F136                  STORE s1, 36[SP_REV_C]
 14A  0B145                  FETCH s1, 45[SP_ORT_T]           ; get value from ort toggle
 14B  1D100                  COMPARE s1, 00                   ; check if this is the first time in this loop
 14C  36157                  JUMP NZ, 157[right_turn2]        ; if not, go to right turn 2 loop
 14D  01001                  LOAD s0, 01                      ; load number to toggle reverse complete
 14E  2F045                  STORE s0, 45[SP_ORT_T]           ; put number into SP_ORT_T so this loop only executed once per 45 degree turn
 14F  003C0                  LOAD s3, sC[Botinf]              ;load the botinfo register value
 150  03307                  AND s3, 07                       ;mask off the unused bits
 151  2F341                  STORE s3, 41[SP_RORT]            ;Store the orientation value into scratch pad
 152  0B147                  FETCH s1, 47[SP_RTS]             ; get value for right turn started
 153  1D100                  COMPARE s1, 00                   ; check if right turn has started
 154  36157                  JUMP NZ, 157[right_turn2]        ; if the right turn has started skip the following STOREs
 155  2F343                  STORE s3, 43[SP_ORT]             ;Store the orientation value into scratch pad (saved only 1 time per whole turn)
 156  2F047                  STORE s0, 47[SP_RTS]             ; put number into SP_RTS so that we know a right turn has started
 157  0B146     right_turn2: FETCH s1, 46[SP_ORT_C]           ; get value from ort complete
 158  1D100                  COMPARE s1, 00                   ; check if ort is complete
 159  3616B                  JUMP NZ, 16B[clean_up1]          ; if yes, go to cleanup1
 15A  003C0                  LOAD s3, sC[Botinf]              ;load the botinfo register value
 15B  03307                  AND s3, 07                       ;mask off the unused bits
 15C  0B041                  FETCH s0, 41[SP_RORT]            ;get the value of the start of the turn
 15D  1C030                  COMPARE s0, s3                   ;see if the bot has turned (see if orientation changed)
 15E  36162                  JUMP NZ, 162[set_tcomp]          ;if the turn is complete set turn complete flag
 15F  01030                  LOAD s0, 30                      ;30 hex = slow right turn
 160  2D009                  OUTPUT s0, 09[PA_MOTCTL_IN]      ;send right turn to motors
 161  25000                  RETURN 
 162  01001       set_tcomp: LOAD s0, 01
 163  2F046                  STORE s0, 46[SP_ORT_C]           ;set that ort is complete
 164  25000                  RETURN 
 165  01200       clean_up2: LOAD s2, 00                      ;used to clean up all variables after line has been found
 166  2F244                  STORE s2, 44[SP_RT_COMP]
 167  01200                  LOAD s2, 00
 168  2F247                  STORE s2, 47[SP_RTS]
 169  01200                  LOAD s2, 00
 16A  2F243                  STORE s2, 43[SP_ORT]
 16B  01200       clean_up1: LOAD s2, 00                      ;only used while line has not been found
 16C  2F234                  STORE s2, 34[SP_STOP]
 16D  01200                  LOAD s2, 00
 16E  2F246                  STORE s2, 46[SP_ORT_C]
 16F  01200                  LOAD s2, 00
 170  2F235                  STORE s2, 35[SP_REV_T]
 171  01200                  LOAD s2, 00
 172  2F236                  STORE s2, 36[SP_REV_C]
 173  01200                  LOAD s2, 00
 174  2F237                  STORE s2, 37[SP_RT_T]
 175  01200                  LOAD s2, 00
 176  2F238                  STORE s2, 38[SP_RT_C]
 177  01200                  LOAD s2, 00
 178  2F239                  STORE s2, 39[SP_RLOCX]
 179  01200                  LOAD s2, 00
 17A  2F240                  STORE s2, 40[SP_RLOCY]
 17B  01200                  LOAD s2, 00
 17C  2F241                  STORE s2, 41[SP_RORT]
 17D  01200                  LOAD s2, 00
 17E  2F242                  STORE s2, 42[SP_FIND]
 17F  01200                  LOAD s2, 00
 180  2F245                  STORE s2, 45[SP_ORT_T]
 181  01200                  LOAD s2, 00
 182  25000                  RETURN 
 183  01100            end1: LOAD s1, 00                      ; load stop into s1
 184  2D109                  OUTPUT s1, 09[PA_MOTCTL_IN]      ; tell Rojobot to stop
 185  25000                  RETURN 
 186                         ;*************************
 186                         ; Nexys4 I/O Functions
 186                         ;*************************
 186                         ;---------------------
 186                         ; DEB_rdbtns() - Reads the debounced pushbuttons
 186                         ;
 186                         ; Returns the 5 pushbuttons. The buttons are returned as follows
 186                         ; (assuming the inputs to the I/O interface matches this order)
 186                         ; example:
 186                         ;    bit  7    6      5        4        3        2        1         0
 186                         ;         r    r      r    btn_cntr  btn_left  btn_up  btn_right  btn_down
 186                         ;
 186                         ; where r = reserved. A value of 1 indicates that the button is pressed.
 186                         ; A 0 indicates that the button is not pressed.
 186                         ;
 186                         ; Registers used s0
 186                         ;---------------------
 186  09000      DEB_rdbtns: INPUT s0, 00[PA_PBTNS]           ; read the buttons
 187  0301F                  AND s0, 1F[MSK_ALLBTNS]          ; mask out unused bits
 188  25000                  RETURN                           ; and return
 189                         ;---------------------
 189                         ; DEB_rdsw() - Reads the low order debounced switches
 189                         ;
 189                         ; Returns the  low order switches  [7:0]. The switches are returned as follows
 189                         ; example:
 189                         ;    bit  7    6    5   4    3    2    1    0
 189                         ;        sw7  sw6  sw5 sw4  sw3  sw2  sw1  sw0
 189                         ;
 189                         ; where r = reserved, sw7 is the leftmost switch and sw0 is the rightmost
 189                         ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 189                         ; the switch is off (down).
 189                         ;
 189                         ; Registers used s0
 189                         ;---------------------
 189  09001        DEB_rdsw: INPUT s0, 01[PA_SLSWTCH]         ; read the slide switches
 18A  030FF                  AND s0, FF[MSK_ALLSW_LO]         ; mask out unused bits
 18B  25000                  RETURN                           ; and return
 18C                         ;---------------------
 18C                         ; DEB_rdsw_hi() - Reads the high order debounced switches
 18C                         ;
 18C                         ; Returns the  high order switches  [155432:0]. The switches are returned as follows
 18C                         ; example:
 18C                         ;    bit   7     6     5    4     3     2     1    0
 18C                         ;        sw15  sw14  sw13 sw12  sw11  sw10  sw9  sw8
 18C                         ;
 18C                         ; where r = reserved, sw15 is the leftmost switch and sw7 is the rightmost
 18C                         ; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
 18C                         ; the switch is off (down).
 18C                         ;
 18C                         ; Registers used s0
 18C                         ;---------------------
 18C  09011     DEB_rdsw_hi: INPUT s0, 11[PA_SLSWTCH1508]     ; read the slide switches
 18D  030FF                  AND s0, FF[MSK_ALLSW_HI]         ; mask out unused bits
 18E  25000                  RETURN                           ; and return
 18F                         ;---------------------
 18F                         ; LED_wrleds() - Write the low order 8 LEDs
 18F                         ;
 18F                         ; Writes the pattern in s1 to the rightmost 8 LEDs on the Nexys4
 18F                         ;
 18F                         ; Registers used s0, s1
 18F                         ;---------------------
 18F  00010      LED_wrleds: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 190  030FF                  AND s0, FF[MSK_LEDS_LO]          ; mask out unused bits
 191  2D002                  OUTPUT s0, 02[PA_LEDS]           ; and write pattern to the LEDs
 192  25000                  RETURN                           ; and return
 193                         ;---------------------
 193                         ; LED_wrleds_hi() - Write the high order 8 LEDs
 193                         ;
 193                         ; Writes the pattern in s1 to the lefmost 8 LEDs on the Nexys4
 193                         ;
 193                         ; Registers used s0, s1
 193                         ;---------------------
 193  00010   LED_wrleds_hi: LOAD s0, s1                      ; Copy LEDs to s0 to preserve them
 194  030FF                  AND s0, FF[MSK_LEDS_HI]          ; mask out unused bits
 195  2D012                  OUTPUT s0, 12[PA_LEDS1508]       ; and write pattern to the LEDs
 196  25000                  RETURN                           ; and return
 197                         ;---------------------
 197                         ; SS_wrdigx() - Write a digit to the righmost 4 display digits
 197                         ;
 197                         ; Writes the value specified in s1 to the digit number
 197                         ; in s2.  The digit number must be 0, 1, 2, or 3
 197                         ; All others numbers will be rejected.
 197                         ;
 197                         ; Registers used s0, s1, s2, s3
 197                         ;---------------------
 197  01003       SS_wrdigx: LOAD s0, 03                      ; check to see if the number is <= 3
 198  1C020                  COMPARE s0, s2                   ;
 199  39000                  RETURN C                         ; C=1 says s2 > 3 - out of range so return
 19A  01006    SS_wrdigx_L1: LOAD s0, 06[PA_DIG0]             ; set base port address to PA_DIG0
 19B  18020                  SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 19C                         ; for the selected digit.  Cool - it works because the port
 19C                         ; addresses for the digits are consecutive starting with digit 3 or 7
 19C  00310                  LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 19D  0331F                  AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 19E  2C300                  OUTPUT s3, (s0)                  ; abd write the digit to the display at the port pointed to by s0
 19F  25000                  RETURN 
 1A0                         ;---------------------
 1A0                         ; SS_wrdigx_hi() - Write a digit to the leftmost 4 display digits
 1A0                         ;
 1A0                         ; Writes the value specified in s1 to the digit number
 1A0                         ; in s2.  The digit number must be 4, 5, 6, 7
 1A0                         ; All others numbers will be rejected.
 1A0                         ;
 1A0                         ; Registers used s0, s1, s2, s3
 1A0                         ;---------------------
 1A0  01007    SS_wrdigx_hi: LOAD s0, 07                      ; check if the number is <= 7
 1A1  1C020                  COMPARE s0, s2                   ;
 1A2  39000                  RETURN C                         ; C=10 says s2 <= 07 - out of range so return
 1A3  01003                  LOAD s0, 03                      ; next check if the number is >= 3
 1A4  1C020                  COMPARE s0, s2                   ; next check if the number is > 3
 1A5  3D000                  RETURN NC                        ; C=0 says s2 < 4 - out of range so return
 1A6  01016                  LOAD s0, 16[PA_DIG4]             ; set base port address to PA_DIG4
 1A7  11004                  ADD s0, 04                       ; adjust digit number offset (ex: digit 4 should be PA_DIG4+4-4)
 1A8  18020                  SUB s0, s2                       ; next subtract out the digit number.  This will give the port address
 1A9                         ; for the selected digit.  Cool - it works because the port
 1A9                         ; addresses for the digits are consecutive starting with digit 3 or 7
 1A9  00310                  LOAD s3, s1                      ; Copy the value to s3 so we can leave it unchanged
 1AA  0331F                  AND s3, 1F[MSK_CCODE]            ; mask out unused character code bits
 1AB  2C300                  OUTPUT s3, (s0)                  ; and write the digit to the display at the port pointed to by s0
 1AC  25000                  RETURN 
 1AD                         ;---------------------
 1AD                         ; SS_wrdpts() - Write the decimal points for digit 3 to 0 to the display
 1AD                         ;
 1AD                         ; Writes the decimal points specified in s1 to the display.
 1AD                         ; The decimal point register is formatted as follows:
 1AD                         ;    bit   7  6  5  4   3    2     1     0
 1AD                         ;          r  r  r  r  dp3  dp2   dp1   dp0
 1AD                         ;
 1AD                         ; where r = reserved, dp7 (leftmost), dp3, dp2, dp1 dp0 (rightmost) = 1
 1AD                         ; lights the decimal point. A 0 in the position turns off the decimal point
 1AD                         ;
 1AD                         ; Registers used s0,s1
 1AD                         ;---------------------
 1AD  00010       SS_wrdpts: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 1AE  0300F                  AND s0, 0F[MSK_DECPTS]           ; and mask out the unused bits
 1AF  2D007                  OUTPUT s0, 07[PA_DP]             ; write the decimal points to the display
 1B0  25000                  RETURN 
 1B1                         ;---------------------
 1B1                         ; SS_wrdpts_hi() - Write the decimal points for digit 7 to 4 to the display
 1B1                         ;
 1B1                         ; Writes the decimal points specified in s1 to the display.
 1B1                         ; The decimal point register is formatted as follows:
 1B1                         ;    bit   7  6  5  4   3    2     1     0
 1B1                         ;          r  r  r  r  dp7  dp6   dp5   dp4
 1B1                         ;
 1B1                         ; where r = reserved, dp7 (leftmost), dp7, dp6, dp5 dp4 (rightmost) = 1
 1B1                         ; lights the decimal point. A 0 in the position turns off the decimal point
 1B1                         ;
 1B1                         ; Registers used s0,s1
 1B1                         ;---------------------
 1B1  00010    SS_wrdpts_hi: LOAD s0, s1                      ; Copy the decimal points to s0 to leave s1 unchanged
 1B2  0300F                  AND s0, 0F[MSK_DECPTS_HI]        ; and mask out the unused bits
 1B3  2D017                  OUTPUT s0, 17[PA_DP0704]         ; write the decimal points to the display
 1B4  25000                  RETURN 
 1B5                         ; =========================
 1B5                         ; === Interrupt Handler ===
 1B5                         ; =========================
 300                         ADDRESS 300
 300  2F621             isr: STORE s6, 21[SP_TEMP1]           ;  save s6, s5
 301  2F522                  STORE s5, 22[SP_TEMP2]           ;
 302  0B620                  FETCH s6, 20[SP_SEM]             ;  fetch the semaphore
 303  0D6FF                  TEST s6, FF                      ; if (SP_SEM == 0) {  // update system register values
 304  3630F                  JUMP NZ, 30F[isr_L0]             ; -- ZF == 0 says semaphore != 0
 305                         ;  // no - get the data from the rojobot emulator
 305  09F0A                  INPUT sF[LocX], 0A[PA_LOCX]      ;  get Rojobot X-coordinate
 306  09E0B                  INPUT sE[LocY], 0B[PA_LOCY]      ;  get Rojobot Y-coordinate
 307  09C0C                  INPUT sC[Botinf], 0C[PA_BOTINFO] ;  get Rojobot Movement and Orientation
 308  09D0D                  INPUT sD[Sensor], 0D[PA_SENSORS] ;  get Rojobot Sensors
 309  0950E                  INPUT s5, 0E[PA_LMDIST]          ;  get left and right motor distance counters
 30A  2F523                  STORE s5, 23[SP_LMDIST]          ;  not displayed in this program but let's stash them
 30B  0950F                  INPUT s5, 0F[PA_RMDIST]          ;  in case we decide we need them
 30C  2F524                  STORE s5, 24[SP_RMDIST]          ;
 30D  11601                  ADD s6, 01                       ;  increment semaphore
 30E  2F620                  STORE s6, 20[SP_SEM]             ; }  // update system register values
 30F  0B627          isr_L0: FETCH s6, 27[SP_OLDDP]           ; toggle  decimal point 0 (rightmost)
 310  07601                  XOR s6, 01                       ;
 311  2D607                  OUTPUT s6, 07[PA_DP]             ; write directly to decpt port to avoid having to save s1
 312  2F627                  STORE s6, 27[SP_OLDDP]           ;
 313  0B621                  FETCH s6, 21[SP_TEMP1]           ;  restore s6, s5
 314  0B522                  FETCH s5, 22[SP_TEMP2]           ;
 315  29001                  RETURNI ENABLE                   ; and return from interrupt
 316                         ; ========================
 316                         ; === Interrupt vector ===
 316                         ; ========================
 3FF                         ADDRESS 3FF
 3FF  22300         intvect: JUMP 300[isr]                    ; jump to interrupt service routine


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\540_proj2\project2_release_r0\firmware_part1\proj2demo\proj2demo.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   10'd         
 timestamp_minutes 39'd         
 timestamp_seconds 35'd         
 datestamp_year    14'd         
 datestamp_month   10'd         
 datestamp_day     30'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PA_PBTNS          00           proj2demo.psm
 PA_SLSWTCH        01           proj2demo.psm
 PA_LEDS           02           proj2demo.psm
 PA_DIG3           03           proj2demo.psm
 PA_DIG2           04           proj2demo.psm
 PA_DIG1           05           proj2demo.psm
 PA_DIG0           06           proj2demo.psm
 PA_DP             07           proj2demo.psm
 PA_RSVD           08           proj2demo.psm
 PA_MOTCTL_IN      09           proj2demo.psm
 PA_LOCX           0A           proj2demo.psm
 PA_LOCY           0B           proj2demo.psm
 PA_BOTINFO        0C           proj2demo.psm
 PA_SENSORS        0D           proj2demo.psm
 PA_LMDIST         0E           proj2demo.psm
 PA_RMDIST         0F           proj2demo.psm
 PA_PBTNS_ALT      10           proj2demo.psm
 PA_SLSWTCH1508    11           proj2demo.psm
 PA_LEDS1508       12           proj2demo.psm
 PA_DIG7           13           proj2demo.psm
 PA_DIG6           14           proj2demo.psm
 PA_DIG5           15           proj2demo.psm
 PA_DIG4           16           proj2demo.psm
 PA_DP0704         17           proj2demo.psm
 PA_RSVD_ALT       18           proj2demo.psm
 PA_MOTCTL_IN_ALT  19           proj2demo.psm
 PA_LOCX_ALT       1A           proj2demo.psm
 PA_LOCY_ALT       1B           proj2demo.psm
 PA_BOTINFO_ALT    1C           proj2demo.psm
 PA_SENSORS_ALT    1D           proj2demo.psm
 PA_LMDIST_ALT     1E           proj2demo.psm
 PA_RMDIST_ALT     1F           proj2demo.psm
 MSK_ALLBTNS       1F           proj2demo.psm
 MSK_PBTNS         0F           proj2demo.psm
 MSK_BTN_CENTER    10           proj2demo.psm
 MSK_BTN_LEFT      08           proj2demo.psm
 MSK_BTN_UP        04           proj2demo.psm
 MSK_BTN_RIGHT     02           proj2demo.psm
 MSK_BTN_DOWN      01           proj2demo.psm
 MSK_ALLSW_LO      FF           proj2demo.psm
 MSK_ALLSW_HI      FF           proj2demo.psm
 MSK_SW7           80           proj2demo.psm
 MSK_SW6           40           proj2demo.psm
 MSK_SW5           20           proj2demo.psm
 MSK_SW4           10           proj2demo.psm
 MSK_SW3           08           proj2demo.psm
 MSK_SW2           04           proj2demo.psm
 MSK_SW1           02           proj2demo.psm
 MSK_SW0           01           proj2demo.psm
 MSK_SW15          80           proj2demo.psm
 MSK_SW14          40           proj2demo.psm
 MSK_SW13          20           proj2demo.psm
 MSK_SW12          10           proj2demo.psm
 MSK_SW11          08           proj2demo.psm
 MSK_SW10          04           proj2demo.psm
 MSK_SW09          02           proj2demo.psm
 MSK_SW08          01           proj2demo.psm
 MSK_LEDS_LO       FF           proj2demo.psm
 MSK_LEDS_HI       FF           proj2demo.psm
 MSK_CCODE         1F           proj2demo.psm
 MSK_DECPTS        0F           proj2demo.psm
 MSK_DECPTS_HI     0F           proj2demo.psm
 MSK_HEXDIGIT      0F           proj2demo.psm
 MSKLOWNIB         0F           proj2demo.psm
 MSKHIGHNIB        F0           proj2demo.psm
 INVLOWNIB         0F           proj2demo.psm
 FALSE             00           proj2demo.psm
 TRUE              01           proj2demo.psm
 NULL              00           proj2demo.psm
 CC_BASE           10           proj2demo.psm
 CC_SEGBASE        10           proj2demo.psm
 CC_SEGA           10           proj2demo.psm
 CC_SEGB           11           proj2demo.psm
 CC_SEGC           12           proj2demo.psm
 CC_SEGD           13           proj2demo.psm
 CC_SEGE           14           proj2demo.psm
 CC_SEGF           15           proj2demo.psm
 CC_SEGG           16           proj2demo.psm
 CC_DOT            17           proj2demo.psm
 CC_UCH            18           proj2demo.psm
 CC_UCL            19           proj2demo.psm
 CC_UCR            1A           proj2demo.psm
 CC_LCL            1B           proj2demo.psm
 CC_LCR            1C           proj2demo.psm
 CC_SPACE1         1D           proj2demo.psm
 CC_SPACE2         1E           proj2demo.psm
 CC_SPACE          1F           proj2demo.psm
 OR_N              00           proj2demo.psm
 OR_NE             01           proj2demo.psm
 OR_E              02           proj2demo.psm
 OR_SE             03           proj2demo.psm
 OR_S              04           proj2demo.psm
 OR_SW             05           proj2demo.psm
 OR_W              06           proj2demo.psm
 OR_NW             07           proj2demo.psm
 MV_STOP           00           proj2demo.psm
 MV_FWD            04           proj2demo.psm
 MV_REV            08           proj2demo.psm
 MV_SLT            0C           proj2demo.psm
 MV_FLT            0D           proj2demo.psm
 MV_SRT            0E           proj2demo.psm
 MV_FRT            0F           proj2demo.psm
 MSKMVMT           0F           proj2demo.psm
 MSKORIENT         07           proj2demo.psm
 SP_BTNBASE        00           proj2demo.psm
 SP_LSRS           00           proj2demo.psm
 SP_LORR           02           proj2demo.psm
 SP_LSRF           03           proj2demo.psm
 SP_LSRFR          00           proj2demo.psm
 SP_LRRS           20           proj2demo.psm
 SP_LRRR           22           proj2demo.psm
 SP_LRRF           23           proj2demo.psm
 SP_LRRFR          20           proj2demo.psm
 SP_LFRS           30           proj2demo.psm
 SP_LFRR           32           proj2demo.psm
 SP_LFRF           33           proj2demo.psm
 SP_LFRFR          30           proj2demo.psm
 SP_LFRRS          00           proj2demo.psm
 SP_LFRRR          02           proj2demo.psm
 SP_LFRRF          03           proj2demo.psm
 SP_LFRRFR         00           proj2demo.psm
 SP_MVMTBASE       10           proj2demo.psm
 SP_MVMT0          18           proj2demo.psm
 SP_MVMT1          17           proj2demo.psm
 SP_MVMT2          17           proj2demo.psm
 SP_MVMT3          17           proj2demo.psm
 SP_MVMT4          0F           proj2demo.psm
 SP_MVMT5          17           proj2demo.psm
 SP_MVMT6          17           proj2demo.psm
 SP_MVMT7          17           proj2demo.psm
 SP_MVMT8          0B           proj2demo.psm
 SP_MVMT9          17           proj2demo.psm
 SP_MVMTA          17           proj2demo.psm
 SP_MVMTB          17           proj2demo.psm
 SP_MVMTC          19           proj2demo.psm
 SP_MVMTD          1B           proj2demo.psm
 SP_MVMTE          1A           proj2demo.psm
 SP_MVMTF          1C           proj2demo.psm
 SP_SEM            20           proj2demo.psm
 SP_TEMP1          21           proj2demo.psm
 SP_TEMP2          22           proj2demo.psm
 SP_LMDIST         23           proj2demo.psm
 SP_RMDIST         24           proj2demo.psm
 SP_OLDMVMT        25           proj2demo.psm
 SP_OLDHDG         26           proj2demo.psm
 SP_OLDDP          27           proj2demo.psm
 SP_DIG7           30           proj2demo.psm
 SP_DIG6           31           proj2demo.psm
 SP_DIG5           32           proj2demo.psm
 SP_DIG4           33           proj2demo.psm
 SP_STOP           34           proj2demo.psm
 SP_REV_T          35           proj2demo.psm
 SP_REV_C          36           proj2demo.psm
 SP_RT_T           37           proj2demo.psm
 SP_RT_C           38           proj2demo.psm
 SP_RLOCX          39           proj2demo.psm
 SP_RLOCY          40           proj2demo.psm
 SP_RORT           41           proj2demo.psm
 SP_FIND           42           proj2demo.psm
 SP_ORT            43           proj2demo.psm
 SP_RT_COMP        44           proj2demo.psm
 SP_ORT_T          45           proj2demo.psm
 SP_ORT_C          46           proj2demo.psm
 SP_RTS            47           proj2demo.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "30 Oct 2014"  
 timestamp$        "10:39:35"     



List of line labels

   Label            Addr  Source PSM File

   main             004   proj2demo.psm
   main_L0          00F   proj2demo.psm
 * main_L2          015   proj2demo.psm
   wr_alldigits     01D   proj2demo.psm
   init_btnluptbl   036   proj2demo.psm
 * btn2mot          067   proj2demo.psm
   init_mvmttbl     06D   proj2demo.psm
   init_find_line   09E   proj2demo.psm
   mvmt2cc          0AE   proj2demo.psm
   next_mvmt        0B4   proj2demo.psm
   next_hdg         0BC   proj2demo.psm
 * nh_caseORN       0BE   proj2demo.psm
   nh_caseORNE      0C4   proj2demo.psm
   nh_caseORE       0CA   proj2demo.psm
   nh_caseORSE      0D0   proj2demo.psm
   nh_caseORS       0D6   proj2demo.psm
   nh_caseORSW      0DC   proj2demo.psm
   nh_caseORW       0E2   proj2demo.psm
   nh_caseORNW      0E8   proj2demo.psm
   nh_endcase       0EB   proj2demo.psm
   next_loc         0EF   proj2demo.psm
 * next_step        100   proj2demo.psm
   find_line        102   proj2demo.psm
   stop             11D   proj2demo.psm
   reverse          12F   proj2demo.psm
   reverse2         13B   proj2demo.psm
   right_turn       147   proj2demo.psm
   right_turn2      157   proj2demo.psm
   set_tcomp        162   proj2demo.psm
   clean_up2        165   proj2demo.psm
   clean_up1        16B   proj2demo.psm
   end1             183   proj2demo.psm
 * DEB_rdbtns       186   proj2demo.psm
 * DEB_rdsw         189   proj2demo.psm
 * DEB_rdsw_hi      18C   proj2demo.psm
   LED_wrleds       18F   proj2demo.psm
 * LED_wrleds_hi    193   proj2demo.psm
   SS_wrdigx        197   proj2demo.psm
 * SS_wrdigx_L1     19A   proj2demo.psm
   SS_wrdigx_hi     1A0   proj2demo.psm
   SS_wrdpts        1AD   proj2demo.psm
   SS_wrdpts_hi     1B1   proj2demo.psm
   isr              300   proj2demo.psm
   isr_L0           30F   proj2demo.psm
 * intvect          3FF   proj2demo.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            135
 STAR              -

 AND              18
 OR                -
 XOR               1

 ADD              34
 ADDCY             -
 SUB               3
 SUBCY             -

 TEST              1
 TESTCY            -
 COMPARE          25
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0              20
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             9
 OUTPUT           12
 OUTPUTK           -

 STORE            23
 FETCH            23

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             35
 JUMP@             -
 CALL             22
 CALL@             -
 RETURN           29
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
